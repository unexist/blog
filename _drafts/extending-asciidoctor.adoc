---
layout: post
title: Extending Asciidoctor
description: This blog post explains how Asciidoctor can easily be extended with new macros with custom functionality like version- and healthchecks.
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: showcase asciidoc asciidoctor asciidoctorj ruby
categories: tech
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/extending_asciidoctor
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/extending_asciidoctor
endif::[]
:figure-caption!:
:table-caption!:

////
https://www.youtube.com/watch?v=2XcJY7abovM
https://docs.freebsd.org/en/books/fdp-primer/asciidoctor-primer/
https://en.wikipedia.org/wiki/AsciiDoc
https://github.com/asciidoctor/asciidoctorj
https://github.com/asciidoctor/asciidoctor/blob/main/lib/asciidoctor/extensions.rb
https://github.com/mgdm/htmlq
https://github.com/asciidoctor/asciidoctor
https://www.baeldung.com/java-spi
https://docs.asciidoctor.org/asciidoc/latest/verbatim/callouts/
https://docs.asciidoctor.org/asciidoc/latest/verbatim/source-blocks/
https://github.com/confluence-publisher/confluence-publisher
////

I am still in the mid of polishing my post about [Gitlab][] and [Podman][] to conclude the
mini series, but had to dive into extending [Asciidoctor][] recently to extend our documentation
on [Confluence][].
This required a bit of good 'ol trial & error and reading code on [Github][], so it probably
is worth my time writing about it and maybe yours as well reading it?

== What is AsciiDoc?

If you've never heard about AsciiDoc before there are plenty of good resources for a primer,
like this article from the [FreeBSD docs][] or even full talks like this one
[Docs-as-Code @ DevConf][] if you want to something to watch.

My own rationale to favor it over like [Markdown][] is the support of [admonitions][],
[callouts][], easy [source code linking][] and the nice [extensibility][] we are going to
look into now.
Obviously since this blog uses AsciiDoc under the hood, many of the named features are also used
to bring this to you.

== Tooling and support

Originally written in [Python][], the new reference implementation is its [Ruby][] rewrite under
the same name, which is ultimately used at various prominent places like [Github][] or even at
[O'Reilly][].

I think everything has a fork that runs on the [JVM][] and probably nobody is surprised this also
applies to Ruby (hello [JRruby][]), so we ultimately are going to use [AsciidoctorJ][].
One advantage of this language mix is we are able to write extensions either Java or in Ruby.

For the ease of use and good sports we are picking the latter.

== Writing an extension

I haven't found a good documentation of the Ruby API besides the actual code on Github, but since
it contains loads of commentary it is quite sufficient.
There are a few different types of extensions that are possible, the one we need is an [inline
macro][].

The bare minimum that is required for any extension to work is this:

[source,ruby]
----
require 'asciidoctor/extensions' unless RUBY_ENGINE == 'opal'

include Asciidoctor

class HelloInlineMacro < Asciidoctor::Extensions::InlineMacroProcessor
    use_dsl

    named :hello # <1>
    name_positional_attributes 'name'

    def process parent, target, attrs # <2>
        create_inline_pass parent, 'Hello, %s!' % attrs['name']
    end
end

Asciidoctor::Extensions.register do # <3>
    if @document.basebackend? 'html'
        inline_macro HelloInlineMacro
    end
end
----
<1> The [DSL][] hopefully is quite easy to read, so this defines the actual name of the macro
<2> We aren't using many features like attributes yet, but this is just to get us started
<3> And lastly we need to register our new extension in the registry

Inside of a document this macro can be used like any other internals:

[source,adoc]
----
hello::[name="World"]
----

[source,shell]
----
$ asciidoctor -r ./hello_inline_macro.rb hello.adoc # <1>
$ htmlq -f hello.html div.paragraph p # <2>
<p>Hello, World!</p>
----
<1> This uses the [asciidoctor gem][]
<2> Never heard of [htmlq][] before? You should have!

This was quite easy, but the original goal is to update docs on Confluence so let us moving forward.

=== Adding a J

Achieving the same with AsciidoctorJ requires a bit of more boilerplate, but still this whole endeavor
is quite doable.

Registration at the registry is a bit more exhaustive and uses a classpath loader and later on
[SPI][]-magic as we are going to see.

Registry loader ahead:

[source,java]
----
package dev.unexist.asciidoctor;

import org.asciidoctor.Asciidoctor;
import org.asciidoctor.jruby.extension.spi.ExtensionRegistry;

public class HelperRegistry implements ExtensionRegistry {

    @Override
    public void register(Asciidoctor asciidoctor) {
        asciidoctor.rubyExtensionRegistry()
            .loadClass(HelperRegistry.class.getResourceAsStream("/extensions/hello-inline-macro.rb"))
            .inlineMacro("hello", "HelloInlineMacro"); # <1>
    }
}
----
<1> See how nice callouts are? Fortunately here is nothing worrying enough for a real comment.

Followed by the magical part:

[source,shell]
----
$ cat src/main/resources/META-INF/services/org.asciidoctor.jruby.extension.spi.ExtensionRegistry # <1>
dev.unexist.asciidoctor.HelperRegistry
----
<1> This facilitates the Java service loader to provide access and a way to extend applications

And easily the messiest part to throw everything into a [pom.xml][]:

[source,xml]
----
<build>
   <plugins>
       <plugin>
           <groupId>org.asciidoctor</groupId>
           <artifactId>asciidoctor-maven-plugin</artifactId>
           <version>${asciidoctor.maven-plugin.version}</version>
           <dependencies>
               <dependency> <!--1-->
                   <groupId>dev.unexist.showcase</groupId>
                   <artifactId>asciidoctor-helper-macros</artifactId>
                   <version>0.1</version>
               </dependency>
           </dependencies>
       </plugin>
   </plugins>
</build>
----
<1> Everything has to be bottled up into a [jar][] - a complete example can be found here:
<https://github.com/unexist/showcase-asciidoc-extensions/blob/master/asciidoctor-helper-macros/pom.xml>

Why, but why is all of this necessary?
We are getting closer!

## Getting this to Confluence

Pushing stuff to Confluence can be done via their REST-API, but fortunately for us there is an easier
way that nicely integrates in all the moving parts we have assembled now.

The [Confluence-Publisher][] plugin comes bundled with Asciidoc support and can nicely talk to the
REST API.
The only drawback here is not all of the features of Asciidoc are currently supported yet (like
tables and having a look at the last change probably never will) yet.

Among the unsupported options is the support to pass Ruby extensions easily, but alas we can add
Java dependencies and follow the SPI approach from before.

I'd like to shorten the mess, but all of this is somehow required:

[source,xml]
----
<build>
   <plugins>
        <plugin>
            <groupId>org.sahli.asciidoc.confluence.publisher</groupId>
            <artifactId>asciidoc-confluence-publisher-maven-plugin</artifactId>
            <version>${confluence.publisher.version}</version>
            <configuration>
                <asciidocRootFolder>${asciidocDirectory}</asciidocRootFolder> <!--1-->
                <sourceEncoding>UTF-8</sourceEncoding>
                <rootConfluenceUrl>${confluence.url}</rootConfluenceUrl>
                <spaceKey>${confluence.spaceKey}</spaceKey> <!--1-->
                <ancestorId>${confluence.ancestorId}</ancestorId>
                <username>${confluence.publisherUserName}</username>
                <password>${confluence.publisherPassword}</password>
                <pageTitlePrefix xml:space="preserve"/>
                <publishingStrategy>${confluence.publishingStrategy}
                </publishingStrategy>
                <orphanRemovalStrategy>KEEP_ORPHANS</orphanRemovalStrategy>
                <pageTitleSuffix
                        xml:space="preserve"> [${project.version}]</pageTitleSuffix>
                <versionMessage>Version ${project.version}</versionMessage>
                <attributes>
                    <version>${project.version}</version>
                </attributes>
            </configuration>
            <executions>
                <execution>
                    <id>publish-documentation</id>
                    <phase>generate-resources</phase>
                    <goals>
                        <goal>publish</goal>
                    </goals>
                </execution>
            </executions>
           <dependencies>
               <dependency> <!--2-->
                   <groupId>dev.unexist.showcase</groupId>
                   <artifactId>asciidoctor-helper-macros</artifactId>
                   <version>0.1</version>
               </dependency>
           </dependencies>
        </plugin>
   </plugins>
</build>
----
<1> The list of supported attributes and flags can be found here:
<https://confluence-publisher.atlassian.net/wiki/spaces/CPD/overview?mode=global>
<2> Remember this from before?

== Conclusion

All examples can be found here:

<https://github.com/unexist/showcase-asciidoc-extensions>

[bibliography]
== Bibliography
