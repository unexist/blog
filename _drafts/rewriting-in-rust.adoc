---
layout: post
title: Rewriting in Rust
description: TBD
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: rust subtle subtle-rs x11 clean-code showcase
categories: tech
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/rewriting_in_rust
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/rewriting_in_rust
endif::[]
:figure-caption!:
:table-caption!:

:rust: https://rust-lang.org/
:windowmanager: https://en.wikipedia.org/wiki/Window_manager
:subtle: https://subtle.de/
:20years: https://hg.unexist.dev/subtle/rev/40917ee3b688
:subtle-rs: https://subtle.rs/
:ai: https://en.wikipedia.org/wiki/Artificial_intelligence
:c2rust: https://github.com/immunant/c2rust
:legacycheck: https://understandlegacycode.com/blog/what-is-legacy-code-is-it-code-without-tests/
:x11: https://en.wikipedia.org/wiki/X_Window_System
:wayland: https://en.wikipedia.org/wiki/Wayland_(protocol)
:gnomex11: https://blogs.gnome.org/alatiera/2025/06/23/x11-session-removal-faq/
:chickenegg: https://en.wikipedia.org/wiki/Chicken_or_the_egg
:loc: https://en.wikipedia.org/wiki/Source_lines_of_code
:sloccount: https://dwheeler.com/sloccount/
:godobject: https://en.wikipedia.org/wiki/God_object
:anti-pattern: https://en.wikipedia.org/wiki/Anti-pattern
:sep-of-concerns: https://en.wikipedia.org/wiki/Separation_of_concerns
:trade-off: https://en.wikipedia.org/wiki/Trade-off
:cell: https://doc.rust-lang.org/std/cell/
:atomic: https://doc.rust-lang.org/core/sync/atomic/index.html
:arc: https://doc.rust-lang.org/std/sync/struct.Arc.html
:let-binding: https://doc.rust-lang.org/rust-by-example/variable_bindings.html

During my career facing legacy code has always been an annoying task and it took me quite some
years to understand, that oftentimes today's code is tomorrow's legacy.
Still, legacy code can be a great opportunity to learn something new and especially when you are
the original author of the piece.

This post jumps on the bandwagon of rewriting everything in {rust}[Rust] and elaborates a bit on my
personal motivation and learnings of rewriting my pet {windowmanager}[window manager] project
{subtle}[subtle], which I started {20years}[~20 years]footnote:[The first commit is actually a bit
older, but apparently moving from CVS > SVN > HG isn't frictionless] ago and still use it on a
daily basis.

== Why?

Among the many things {ai}[AI] can _do for us_, migrating code from one language into another is
usually a strong selling point and even without AI there are excellent tools on its own, like
{c2rust}[C2Rust], to get the job done with just a flick of a finger.

So why is an excellent question.

One of my main motivators isn't just to get the job done, like I lamented on a bit in my
{{ site.url }}{% post_url 2025-09-22-fear_of_missing_out_on_ai %}[previous blog post], but to have
a learning experience and take something from it besides another code base, which easily ticks
every point of the {legacycheck}[legacy code checklist].

Manual labor isn't probably the most controversial aspect of it, but porting an {x11}[X11]
application in the [line-through]#day# [line-through]#year# epoch of {wayland}[Wayland] might look
like a waste of time.

Alas, the reasoning here is basically the same.
Plus I've spent many years with X11 learning its core concepts and *still* like the system and
capabilities.

On a side note - I am not entirely certain there is a giant switch to get rid of it, despite how
decisions of e.g. the {gnomex11}[GNOME project]footnote:[GNOME and I had some intermezzos back
then, but that is more than a decade ago.] might appear.

== Learnings so far

Porting a codebase, like the one of subtle with 14728 {loc}[LoC] (according to
{sloccount}[sloccount]footnote:[The underlying model is good way to annoy every developer, but the
tool is still nice to count lines.]), brought loads of challenges with it.
Some of them were the usual ones like "where to start" and how can this be done in language X, but
let us concentrate here a handful of interesting points.

NOTE: The problems are inter-related, and it is sometimes a {chickenegg}[chicken or the egg]-type
of problem which to address first, so please be prepared to jump a bit around if necessary.

=== God objects

When I started subtle back then, I didn't even know that this pattern is called
{godobject}[God Object] or that it is considered to be prime example of an
{anti-pattern}[anti-pattern].
To me it was something that I've learned by reading other people's code and looked like a good
solution for a problem, which is still relevant today.

==== Problem

The main problem is kind of easy to explain and mainly related to software design:
Your program needs to keep track of data like state or socket descriptors and many related functions
have to access and sometimes mutate them.

There are several ways to tackle it, like moving everything related together, but this can also
mean there is basically just one big file and C isn't the strongest language to enforce a proper
structure and coherence.
It was way easier to have a global object which included every bit and was available throughout
the program.

This might obviously lead to interesting side-effects in multi-threaded applications, but
fortunately the design goal of subtle has always been to be single-threaded and no other means of
locking were required.

What I did not understand back then and which is more of concern here, is the implicit coupling of
everything to this god object.
This means changing the god object may require changes of other parts of the program and also may
unknowingly break other parts of the application.

==== Solution

subtle-rs (as its predecessor) is event-driven and many parts revolve around a single connection to
the X11 server.
This connection must be available to most parts and moving everything into the holding object made
proper {sep-of-concerns}}[separation of concerns] more difficult.

Like every worth-while decision this is a classical {trade-off}[trade-off] and the original design
was kept with the addition to carry the dependency *explicitly* through the codebase.

.subtle/client.c \(C):
[source,c]
----
void subClientSetSizeHints(SubClient *c, int *flags) {
...
}
----

.subtle-rs/client.rs (Rust):
[source,rust]
----
pub(crate) fn set_size_hints(&mut self, subtle: &Subtle, mode_flags: &mut ClientFlags) -> Result<()> { // <.>
...
}
----
<.> Another benefit of Clean Code

=== Interior mutability

Since the last problem was that easy to solve, let us face a new problem, that mainly has been
introduced due to our easy approach before.
I've never seen this problem in other languages before, nonetheless I still think this is relevant
to other languages.

==== Problem

We are happily carrying our reference to our let us say demi-god object around, everything can
access and read the data and some use-cases work splendidly.
Now what happens when something wants to actually mutate (write) the data?

The compiler (or rather the borrow checker) happily reminds us, that there can only be one mutable
reference at the same time and the aliasing rules are violated:

[source,shell]
----
error[E0499]: cannot borrow `subtle` as mutable more than once at a time
----

NOTE: Strictly speaking in a linear and single-threaded application this problem shouldn't occur,
but the borrow checker cannot know that at compile-time.

==== Solution

The next problem explains why we cannot just use mutable references everywhere, but there are
other ways to tell the compiler we are aware and extra careful - namely interior mutability.

In a nutshell this means we are wrapping the data inside an extra container, pass the container
around and move its data in and out according to our use-case.

This is a pretty common problem and Rust provides many different options like
{cell}[Cell and RefCell], {atomic}[Atomic] and some more advanced options like the smart pointer
{arc}[Arc] for more shenanigans.footnote:[Interior mutabilty is sometimes also called escape hatch..]

.subtle/screen.c \(C):
[source,c]
----
void subScreenConfigure(void) {
...
    /* Reset visible tags, views and available clients */
    subtle->visible_tags = 0; // <.>
...
    /* Set visible tags and views to ease lookups */
    subtle->visible_tags |= v->tags;
...
}
----
<.> No one can stop us from just accessing our god object directly.

.subtle-rs/screen.rs (Rust):
[source,rust]
----
pub(crate) fn configure(subtle: &Subtle) -> Result<()> {
...
    // Reset visible tags, views and available clients
    let mut visible_tags = Tagging::empty(); // <.>
...
    // Set visible tags and views to ease lookups
    visible_tags.insert(view.tags);
...
    subtle.visible_tags.replace(visible_tags); // <.>
...
}
----
<.> This is a pretty easy case: First we introduce a local variable via {let-binding}[let binding].
<.> And then once we are happy with the result we ask the container to swap the content entirely.


=== Borrow checker

=== Explicit copies

== Conclusion

All examples can be found here:

<https://github.com/unexist/subtle-rs>
