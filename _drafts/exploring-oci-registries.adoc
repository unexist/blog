---
layout: post
title: Exploring OCI registries
description: This blog post demonstrates how ORAS can be used to leverage OCI-compliant registries to handle all kind of artifacts.
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: container oci sbom oras cosign trivy grype syft cyclodedx showcase
categories: tech
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/exploring_oci_registries
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/exploring_oci_registries
endif::[]
:figure-caption!:
:table-caption!:
:page-liquid:

:podman: https://podman.io/
:oci: https://opencontainers.org/
:oras: https://oras.land/
:sbom: https://about.gitlab.com/blog/2022/10/25/the-ultimate-guide-to-sboms/
:harbor: https://goharbor.io/
:runtimespec: https://github.com/opencontainers/runtime-spec/blob/main/spec.md
:imagespec: https://github.com/opencontainers/image-spec/blob/main/spec.md
:distspec: https://github.com/opencontainers/distribution-spec/blob/main/spec.md
:github: https://github.com
:json: https://www.json.org/
:mediaspec: https://specs.opencontainers.org/image-spec/media-types/
:zotreg: https://zotregistry.dev/
:zotregweb: https://zotregistry.dev/v2.1.0/user-guides/user-guide-gui/
:trivy: https://trivy.dev/latest/
:heosdial: https://github.com/unexist/heos-dial
:cve: https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures
:cyclondedx: https://cyclonedx.org/

Handling containers is probably something a modern developer can't and probably *should* not live
without anymore.
They provide flexibility, allow easy packaging and also sandboxing of stuff you might not want
to have installed on your machine.

Like so often in tech, using something successfully doesn't imply real understanding how it
works under the hood, but I lived quite happily with this black box and all greasy details
shrouded in mysteries hidden behind tooling like {podman}[Podman].
This changed, when I started looking for an artifact store for our firmware binary artifacts.
I quickly discovered there are many container registries available, but just a few stores for
_ordinary_ artifacts without spending large parts of our engineering budget on enterprise
license fees.
Passing this question to my bubble lead to a suggestion of a good friend  to have a look at
{oras}[ORAS], which leverages {oci}[OCI]-compliant registries for exactly what I wanted to
literally archive.
We are already using Harbor][], so moving other artifacts there as well aroused my interest.

So over the course of this article we are going to dive into the container world with a short
primer of the duality of OCI, talk about basic usage and a few advanced points like {sbom}[SBOM]
and signing and conclude with my impression on the technology.

NOTE: This post includes several introductional chapters as a deep dive into a specific topic.
If you are just here for the examples and how to use the tooling quickly jump ahead and wait for us.

== What is OCI?

Turns out the {oci}[Open Container Initiative (OCI)] isn't a single spec by itself, but rather
a governance body around several container formats and runtimes - namely:

- Runtime Specification ({runtimespec}[runtime-spec])
- Image Specification ({imagespec}[image-spec])
- Distribution Specification ({distspec}[distribution-spec])

The links lead to the related {github}[GitHub] projects in case you want to build your own
container engine, but I suggest we focus on *image-spec*, which lays out the structure in all gory
details.

=== Containers inside out

If you've dutifully studied the spec the overall structure of an actual container will probably
not surprise you.
If not believe me, they are less magically than thought, can be fetched with the help of Podman
and easily be dissected on the shell:

[source,shell]
----
$ podman save ghcr.io/oras-project/oras:main -o oras.tar
Copying blob 08000c18d16d done   |
...
Writing manifest to image destination
$ tar xvf oras.tar --one-top-level
08000c18d16dadf9553d747a58cf44023423a9ab010aab96cf263d2216b8b350.tar
...
manifest.json
repositories
$ tree oras
oras
├── 08000c18d16dadf9553d747a58cf44023423a9ab010aab96cf263d2216b8b350.tar
...
├── 29ec8736648c6f233d234d989b3daed3178a3ec488db0a41085d192d63321c72
    ├── json
    ├── layer.tar -> ../08000c18d16dadf9553d747a58cf44023423a9ab010aab96cf263d2216b8b350.tar
    └── VERSION
...
├── manifest.json
└── repositories

6 directories, 23 files
----

Following links in {json}[JSON]-files and memorizing digests is a bit
cumbersomefootnote:[At least to me], so let us try arrows instead.

=== Containers mapped out

[plantuml]
----
'"!theme unexist from {{ site.asciidoctor_attributes.plantumldir }}

'skinparam linetype ortho
skinparam nodesep 20
skinparam ranksep 20

package "Index (5)" as index {
    json "Manifests" as index_manifests {
        [
            {
                "mediaType": "<back:wheat>application/vnd.oci.image.manifest.v1+json",
                "size": "<i>$(du --bytes manifest.json)",
                "digest": "sha256:<back:goldenrod><i>$(sha256 manifest.json)",
                "platform": {
                    "architecture": "amd64",
                    "os": "linux"
                }
            }
        ]
    }

    json "Annotations" as index_annotations {
        "blog.unexist.author": "unexist",
        "blog.unexist.title": "Exploring OCI registries"
    }
}

package "Blobs (1)" as blobs {
    file "Manifest amd64/linux" as blobs_manifest_amd64 #goldenrod
    file "Config amd64/linux" as blobs_config_amd64 #deepskyblue
    file "Layer 1" as blobs_l1 #palegreen
    file "Layer 2" as blobs_l2 #palegreen
    file "Layer n" as blobs_ln
}

package "Manifest (4)" as manifest {
    json "Config" as manifest_config {
        "mediaType": "<back:wheat>application/vnd.oci.image.config.v1+json",
        "size": "<i>$(du --bytes config.json)",
        "digest": "sha256:<back:deepskyblue><i>$(sha256 config.json)"
    }

    json "Layers (5)" as manifest_layers {
        [
            {
                "mediaType": "<back:wheat>application/vnd.oci.image.layer.v1.tar",
                "size": "<i>$(du --bytes layer1.tar)",
                "digest": "sha256:<i><back:palegreen>$(sha256 layer1.tar)"
            },
            {
                "mediaType": "application/vnd.oci.image.layer.v1.tar",
                "size": "<i>$(du --bytes layer2.tar)",
                "digest": "sha256:<i><back:palegreen>$(sha256 layer2.tar)"
            }
        ]
    }
}

package "Config (2)" as configs {
    json "Meta" as config_attrs {
        "created": "<i>$(date --iso-8601=ns)",
        "author": "unexist",
        "architecture": "amd64",
        "os": "linux"
    }

    json "rootfs (3)" as config_rootfs {
       "diff_ids": [
            "sha256:<i><back:palegreen>$(sha256 layer1.tar)",
            "sha256:<i><back:palegreen>$(sha256 layer2.tar)"
        ]
    }
}

' Arrows
manifest o-l-o blobs_manifest_amd64 #goldenrod
configs o-r-o blobs_config_amd64 #mediumpurple

config_rootfs -> blobs_l1
config_rootfs -> blobs_l2

manifest_layers -> blobs_l1
manifest_layers -> blobs_l2

' Global placement
index -[hidden]r-> blobs
index -[hidden]d-> manifest
manifest -[hidden]l-> blobs
blobs -[hidden]r-> configs

' Index
index_manifests -[hidden]d-> index_annotations

' Blobs
blobs_manifest_amd64 -[hidden]d-> blobs_config_amd64
blobs_config_amd64 -[hidden]d-> blobs_l1
blobs_l1 -[hidden]d-> blobs_l2
blobs_l2 -[hidden]d-> blobs_ln

' Manifests
manifest_config -[hidden]d-> manifest_layers

' Configs
config_attrs -[hidden]d-> config_rootfs
----
<1> *Blobs* is the main directory with all adressable filesystem layers and their related metadata
defined in the appropriate JSON files _config_ and _manifest_.
_The name of the layers are actually digests as well, but to make it easier to follow let us keep the
fancy numbers._
<2> *Config* contains entries like meta information about author as well as other runtime
information like environment variables, entrypoints, volume mounts etc. as well as infos about
specific hardware architecture and OS.
<3> *rootfs* contains an ordered list of the digests that compose the actual image.
<4> The *manifest* just links to the actual configugration by digest and to the layers.
<5> And finally the *index* includes all available manifests and also image annotations.

Mysteries solved, but there is still one essential piece missing - namely media types.

=== What are media types?

This surprises probably no one, but media types are also covered by a spec
footnote:[Really the last one for the course of this post..] - the {mediaspec}[media-spec]

There you can see the exhaustive list of the known types and an implementor's todo list in order to
be compliant.
Conversely, this means as long as we pick something different we are free to swap out or fill
layers with anything to our liking without triggering a certain behaviour accidentally.

== Use-Cases

The next few examples require an OCI-compatible registry and also accessible *oras* and *cosign*
binaries.
Since installation is usually a hassle, all examples rely on Podman and the well-supported
{zotreg}[Zot Registry].

== Firing up Zot

Firing up our registry is just a piece of cake and shouldn't raise any eyebrows yet.
We pretty much set just the bare essentials - *deliberately* without any hardening for actual
logins.

[source,shell]
----
$ podman run --rm -it --name zot-registry -p 5000:5000 --network=host \
  -v ./infrastructure/zot-registry/config.json:/etc/zot/config.json \ <.>
  ghcr.io/project-zot/zot-linux-amd64:v2.1.2
----
<1> Apart from defaults we also want to enable the fancy {zotregweb}[web ui] and the {cve}[CVE]
scanner - have a glimpse how this can be done on GitHub: +
<https://github.com/unexist/showcase-oci-registries/blob/master/infrastructure/zot-registry/config.json>

Once started and after the initial download of the vulnerabilities database of {trivy}[Trivy] we
are dutifully greeted with an empty list:

image::zot-empty.png[]

Time to push our first artifact!

=== Pushing a binary artifact

My original idea is

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \ <.>
    ghcr.io/oras-project/oras:main \
    push localhost:5000/todo-service:latest \
        --artifact-type showcase/todo-service \ <.>
        todo-service/todo-service.bin:application/octet-stream \
        --plain-http
✓ Uploaded  todo-service/todo-service.bin                                                                                                                                                                                                            26.1/26.1 MB 100.00%   33ms
  └─ sha256:cc8ab19ee7e1f1f7d43b023317c560943dd2c15448ae77a83641e272bc7a5dbc
✓ Uploaded  application/vnd.oci.empty.v1+json                                                                                                                                                                                                              2/2  B 100.00%    4ms
  └─ sha256:44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a
✓ Uploaded  application/vnd.oci.image.manifest.v1+json                                                                                                                                                                                                 578/578  B 100.00%    7ms
  └─ sha256:845c637a8ce8e1b3badf7e727682f7cbbfccaedeaebeb8936ba23324f7d530d0
Pushed [registry] localhost:5000/todo-service:latest
ArtifactType: showcase/todo
Digest: sha256:845c637a8ce8e1b3badf7e727682f7cbbfccaedeaebeb8936ba23324f7d530d0
----
<.> The ORAS container allows us to call it this way and directly pass our arguments.
<.> Here we set our custom artifact type, to be able to distinguish it.

=== Pulling it back



==== Pull with Podman

Pulling images from container registries is best done with Podman directly:

[source,shell]
----
$ podman pull localhost:5000/todo-service:latest
Trying to pull localhost:5000/todo-service:latest...
Error: parsing image configuration: unsupported image-specific operation on artifact with type "showcase/todo-service" # <.>
----
<.> Unsurprisingly Podman doesn't understand our custom artifact type and hence refuses to do our
bidding.

[NOTE]
====
If Podman cannot connect to your local registry and bails out with
`http: server gave HTTP response to HTTPS client` please make sure to add your *insecure* registry
to your _/etc/containers/registries.conf_ file:

[source,shell]
----
$ tail -n2 /etc/containers/registries.conf
[registries.insecure]
registries = ['localhost:5000']
----
====

==== Can ORAS pull the image?

Let us try again - this time with ORAS.

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \
    ghcr.io/oras-project/oras:main \
    pull localhost:5000/todo-service:latest --plain-http
✓ Pulled      todo-service/todo-service.bin                                                                                                                                                                                                          26.1/26.1 MB 100.00%   35ms
  └─ sha256:cc8ab19ee7e1f1f7d43b023317c560943dd2c15448ae77a83641e272bc7a5dbc
✓ Pulled      application/vnd.oci.image.manifest.v1+json                                                                                                                                                                                               578/578  B 100.00%   50µs
  └─ sha256:845c637a8ce8e1b3badf7e727682f7cbbfccaedeaebeb8936ba23324f7d530d0
Pulled [registry] localhost:5000/todo-service:latest
Digest: sha256:845c637a8ce8e1b3badf7e727682f7cbbfccaedeaebeb8936ba23324f7d530d0
$ tree todo-service
todo-service
└── todo-service.bin

1 directory, 1 file
----

=== Print information about the image

There are several commands available to gather information about images on the registry.

==== Fetching the manifest

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \
    ghcr.io/oras-project/oras:main \
    manifest fetch --pretty \
    localhost:5000/todo-service:latest --plain-http
{
  "schemaVersion": 2,
  "mediaType": "application/vnd.oci.image.manifest.v1+json",
  "artifactType": "showcase/todo-service",
  "config": {
    "mediaType": "application/vnd.oci.empty.v1+json",
    "digest": "sha256:44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a",
    "size": 2,
    "data": "e30="
  },
  "layers": [
    {
      "mediaType": "application/octet-stream",
      "digest": "sha256:cc8ab19ee7e1f1f7d43b023317c560943dd2c15448ae77a83641e272bc7a5dbc",
      "size": 27352532,
      "annotations": {
        "org.opencontainers.image.title": "todo-service/todo-service.bin"
      }
    }
  ],
  "annotations": {
    "org.opencontainers.image.created": "2025-06-04T06:52:13Z"
  }
}
----

====

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \
    ghcr.io/oras-project/oras:main \
    discover --format tree \
    localhost:5000/todo-service:latest --plain-http
localhost:5000/todo-service@sha256:845c637a8ce8e1b3badf7e727682f7cbbfccaedeaebeb8936ba23324f7d530d0
----

=== Excursion: Using SBOM

== Conclusion

All examples can be found here:

<https://github.com/unexist/showcase-oci-registries>

[bibliography]
== Bibliography
