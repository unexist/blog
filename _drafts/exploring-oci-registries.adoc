---
layout: post
title: Exploring OCI registries
description: This blog post demonstrates how ORAS can be used to leverage OCI-compliant registries to handle all kind of artifacts.
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: container oci sbom oras cosign trivy grype syft cyclodedx showcase
categories: tech
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/exploring_oci_registries
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/exploring_oci_registries
endif::[]
:figure-caption!:
:table-caption!:
:page-liquid:

:podman: https://podman.io/
:oci: https://opencontainers.org/
:oras: https://oras.land/
:sbom: https://about.gitlab.com/blog/2022/10/25/the-ultimate-guide-to-sboms/
:harbor: https://goharbor.io/
:runtimespec: https://github.com/opencontainers/runtime-spec/blob/main/spec.md
:imagespec: https://github.com/opencontainers/image-spec/blob/main/spec.md
:distspec: https://github.com/opencontainers/distribution-spec/blob/main/spec.md
:github: https://github.com
:json: https://www.json.org/
:mediaspec: https://specs.opencontainers.org/image-spec/media-types/
:zotreg: https://zotregistry.dev/
:zotregweb: https://zotregistry.dev/v2.1.0/user-guides/user-guide-gui/
:cve: https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures
:trivy: https://trivy.dev/latest/
:heosdial: https://github.com/unexist/heos-dial
:golang: https://go.dev/
:redoc: https://unexist.blog/redoc
:orascmds: https://oras.land/docs/category/oras-commands
:blobs: https://de.wikipedia.org/wiki/Binary_Large_Object
:helm: https://helm.sh/
:log4j: https://en.wikipedia.org/wiki/Log4Shell
:spdx: https://en.wikipedia.org/wiki/Software_Package_Data_Exchange
:cyclondedx: https://cyclonedx.org/
:syft: https://github.com/anchore/syft
:grype: https://github.com/anchore/grype

Handling containers is probably something a modern developer can't and probably *should* not live
without anymore.
They provide flexibility, allow easy packaging and also sandboxing of stuff you might not want
to have installed on your machine.

Like so often in tech, using something successfully doesn't imply real understanding how it
works under the hood, but I lived quite happily with this black box and all greasy details
shrouded in mysteries hidden behind tooling like {podman}[Podman].
This changed, when I started looking for an artifact store for our firmware binary artifacts.
I quickly discovered there are many container registries available, but just a few stores for
_ordinary_ artifacts without spending large parts of our engineering budget on enterprise
license fees.
Passing this question to my bubble lead to a suggestion of a good friend  to have a look at
{oras}[ORAS], which leverages {oci}[OCI]-compliant registries for exactly what I wanted to
literally archive.
We are already using Harbor][], so moving other artifacts there as well aroused my interest.

So over the course of this article we are going to dive into the container world with a short
primer of the duality of OCI, talk about basic usage and a few advanced points like {sbom}[SBOM]
and signing and conclude with my impression on the technology.

NOTE: This post includes several introductional chapters as a deep dive into a specific topic.
If you are just here for the examples and how to use the tooling quickly jump ahead and wait for us.

== What is OCI?

Turns out the {oci}[Open Container Initiative (OCI)] isn't a single spec by itself, but rather
a governance body around several container formats and runtimes - namely:

- Runtime Specification ({runtimespec}[runtime-spec])
- Image Specification ({imagespec}[image-spec])
- Distribution Specification ({distspec}[distribution-spec])

The links lead to the related {github}[GitHub] projects in case you want to build your own
container engine, but I suggest we focus on *image-spec*, which lays out the structure in all gory
details.

=== Containers inside out

If you've dutifully studied the spec the overall structure of an actual container will probably
not surprise you.
If not believe me, they are less magically than thought, can be fetched with the help of Podman
and easily be dissected on the shell:

[source,shell]
----
$ podman save ghcr.io/oras-project/oras:main -o oras.tar
Copying blob 08000c18d16d done   |
...
Writing manifest to image destination
$ tar xvf oras.tar --one-top-level
08000c18d16dadf9553d747a58cf44023423a9ab010aab96cf263d2216b8b350.tar
...
manifest.json
repositories
$ tree oras
oras
├── 08000c18d16dadf9553d747a58cf44023423a9ab010aab96cf263d2216b8b350.tar
...
├── 29ec8736648c6f233d234d989b3daed3178a3ec488db0a41085d192d63321c72
    ├── json
    ├── layer.tar -> ../08000c18d16dadf9553d747a58cf44023423a9ab010aab96cf263d2216b8b350.tar
    └── VERSION
...
├── manifest.json
└── repositories

6 directories, 23 files
----

Following links in {json}[JSON]-files and memorizing digests is a bit
cumbersomefootnote:[At least to me], so let us try arrows in a diagram instead.

=== Containers mapped out

[plantuml]
----
'"!theme unexist from {{ site.asciidoctor_attributes.plantumldir }}

'skinparam linetype ortho
skinparam nodesep 20
skinparam ranksep 20

package "Index (5)" as index {
    json "Manifests" as index_manifests {
        [
            {
                "mediaType": "<back:wheat>application/vnd.oci.image.manifest.v1+json",
                "size": "<i>$(du --bytes manifest.json)",
                "digest": "sha256:<back:goldenrod><i>$(sha256 manifest.json)",
                "platform": {
                    "architecture": "amd64",
                    "os": "linux"
                }
            }
        ]
    }

    json "Annotations" as index_annotations {
        "blog.unexist.author": "unexist",
        "blog.unexist.title": "Exploring OCI registries"
    }
}

package "Blobs (1)" as blobs {
    file "Manifest amd64/linux" as blobs_manifest_amd64 #goldenrod
    file "Config amd64/linux" as blobs_config_amd64 #deepskyblue
    file "Layer 1" as blobs_l1 #palegreen
    file "Layer 2" as blobs_l2 #palegreen
    file "Layer n" as blobs_ln
}

package "Manifest (4)" as manifest {
    json "Config" as manifest_config {
        "mediaType": "<back:wheat>application/vnd.oci.image.config.v1+json",
        "size": "<i>$(du --bytes config.json)",
        "digest": "sha256:<back:deepskyblue><i>$(sha256 config.json)"
    }

    json "Layers (5)" as manifest_layers {
        [
            {
                "mediaType": "<back:wheat>application/vnd.oci.image.layer.v1.tar",
                "size": "<i>$(du --bytes layer1.tar)",
                "digest": "sha256:<i><back:palegreen>$(sha256 layer1.tar)"
            },
            {
                "mediaType": "application/vnd.oci.image.layer.v1.tar",
                "size": "<i>$(du --bytes layer2.tar)",
                "digest": "sha256:<i><back:palegreen>$(sha256 layer2.tar)"
            }
        ]
    }
}

package "Config (2)" as configs {
    json "Meta" as config_attrs {
        "created": "<i>$(date --iso-8601=ns)",
        "author": "unexist",
        "architecture": "amd64",
        "os": "linux"
    }

    json "rootfs (3)" as config_rootfs {
       "diff_ids": [
            "sha256:<i><back:palegreen>$(sha256 layer1.tar)",
            "sha256:<i><back:palegreen>$(sha256 layer2.tar)"
        ]
    }
}

' Arrows
manifest o-l-o blobs_manifest_amd64 #goldenrod
configs o-r-o blobs_config_amd64 #mediumpurple

config_rootfs -> blobs_l1
config_rootfs -> blobs_l2

manifest_layers -> blobs_l1
manifest_layers -> blobs_l2

' Global placement
index -[hidden]r-> blobs
index -[hidden]d-> manifest
manifest -[hidden]l-> blobs
blobs -[hidden]r-> configs

' Index
index_manifests -[hidden]d-> index_annotations

' Blobs
blobs_manifest_amd64 -[hidden]d-> blobs_config_amd64
blobs_config_amd64 -[hidden]d-> blobs_l1
blobs_l1 -[hidden]d-> blobs_l2
blobs_l2 -[hidden]d-> blobs_ln

' Manifests
manifest_config -[hidden]d-> manifest_layers

' Configs
config_attrs -[hidden]d-> config_rootfs
----
<1> *Blobs* is the main directory with all adressable filesystem layers and their related metadata
defined in the appropriate JSON files _config_ and _manifest_.
_The name of the layers are actually digests as well, but to make it easier to follow let us keep the
fancy numbers._
<2> *Config* contains entries like meta information about author as well as other runtime
information like environment variables, entrypoints, volume mounts etc. as well as infos about
specific hardware architecture and OS.
<3> *rootfs* contains an ordered list of the digests that compose the actual image.
<4> The *manifest* just links to the actual configugration by digest and to the layers.
<5> And finally the *index* includes all available manifests and also image annotations.

Mysteries solved, but there is still one essential piece missing - namely media types.

=== What are media types?

This surprises probably no one, but media types are also covered by a spec
footnote:[Really the last one for the course of this post..] - the {mediaspec}[media-spec]

There you can see the exhaustive list of the known types and an implementor's todo list for
compliance to the specs.
Conversely, this also means as long as we pick something different we are free to fill layers with
anything to our liking without triggering a certain behaviour accidentally.

== Use-Cases

The next few examples require an OCI-compatible registry and also access to the binaries of
*oras* and *cosign* and some more.
Since installation is usually a hassle, all examples rely on Podman and the well-supported
{zotreg}[Zot Registry].

== Firing up Zot

Setting up our registry is just a piece of cake and shouldn't raise any eyebrows yet.
We pretty much set just the bare essentials - *deliberately* without any hardening for actual
logins.

[source,shell]
----
$ podman run --rm -it --name zot-registry -p 5000:5000 --network=host \
  -v ./infrastructure/zot-registry/config.json:/etc/zot/config.json \ # <.>
  ghcr.io/project-zot/zot-linux-amd64:v2.1.2
----
<1> Apart from host stuff we also want to enable the fancy {zotregweb}[web ui] and the {cve}[CVE]
scanner - have a glimpse how this can be done on GitHub: +
<https://github.com/unexist/showcase-oci-registries/blob/master/infrastructure/zot-registry/config.json>

Once started and after the initial download of the vulnerabilities database of {trivy}[Trivy] we
are dutifully greeted with an empty list:

image::zot-empty.png[]

Time to push our first artifact!

=== Pushing a binary artifact

Ultimately I want to push embedded software artifacts to the registry, but since this is public
and my own project {heosdial}[heos-dial] isn't ready yet we are pushing a binary of the
{golang}[Golang] version of my faithful {redoc}[todo service]:

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \ # <.>
    ghcr.io/oras-project/oras:main \
    push localhost:5000/todo-service:latest \
        --artifact-type showcase/todo-service \ # <.>
        --plain-http \ # <.>
        todo-service/todo-service.bin:application/octet-stream
✓ Uploaded  todo-service/todo-service.bin                                                                                                                                                                                                            26.1/26.1 MB 100.00%   32ms
  └─ sha256:cc8ab19ee7e1f1f7d43b023317c560943dd2c15448ae77a83641e272bc7a5dbc
✓ Uploaded  application/vnd.oci.empty.v1+json                                                                                                                                                                                                              2/2  B 100.00%    7ms
  └─ sha256:44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a
✓ Uploaded  application/vnd.oci.image.manifest.v1+json                                                                                                                                                                                                 586/586  B 100.00%    7ms
  └─ sha256:fb1f02fff7f1406ae3aa2d9ebf3f931910b69e99c95e78e211037f11ec8f1eb6
Pushed [registry] localhost:5000/todo-service:latest
ArtifactType: showcase/todo-service
Digest: sha256:fb1f02fff7f1406ae3aa2d9ebf3f931910b69e99c95e78e211037f11ec8f1eb6
----
<.> The ORAS container allows us to call it this way and directly pass our arguments.
<.> Here we set our custom artifact type, to be able to distinguish it.
<.> No need to make our live miserable with SSL/TLS!

=== Pulling it back

One-way-success, time to get it back:

==== Pull with Podman

Pulling images from container registries is one of the core tasks of Podman:

[source,shell]
----
$ podman pull localhost:5000/todo-service:latest
Trying to pull localhost:5000/todo-service:latest...
Error: parsing image configuration: unsupported image-specific operation on artifact with type "showcase/todo-service" # <.>
----
<.> Unsurprisingly Podman doesn't understand our custom artifact type and hence refuses to do our
bidding.

[NOTE]
====
If Podman cannot connect to your local registry and bails out with
`http: server gave HTTP response to HTTPS client` please make sure to add your *insecure* registry
to your _/etc/containers/registries.conf_ file:

[source,shell]
----
$ tail -n2 /etc/containers/registries.conf
[registries.insecure]
registries = ['localhost:5000']
----
====

==== Can ORAS pull the image?

Let us try again - this time with ORAS.

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \
    ghcr.io/oras-project/oras:main \
    pull localhost:5000/todo-service:latest --plain-http
✓ Pulled      todo-service/todo-service.bin                                                                                                                                                                                                          26.1/26.1 MB 100.00%   38ms
  └─ sha256:cc8ab19ee7e1f1f7d43b023317c560943dd2c15448ae77a83641e272bc7a5dbc
✓ Pulled      application/vnd.oci.image.manifest.v1+json                                                                                                                                                                                               586/586  B 100.00%   66µs
  └─ sha256:fb1f02fff7f1406ae3aa2d9ebf3f931910b69e99c95e78e211037f11ec8f1eb6
Pulled [registry] localhost:5000/todo-service:latest
Digest: sha256:fb1f02fff7f1406ae3aa2d9ebf3f931910b69e99c95e78e211037f11ec8f1eb6
$ tree todo-service
todo-service
└── todo-service.bin

1 directory, 1 file
----

=== Print information about the image

There are several commands available to gather information about images on the registry.

==== Fetching the manifest

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \
    ghcr.io/oras-project/oras:main \
    manifest fetch --pretty --plain-http \
    localhost:5000/todo-service:latest
{
  "schemaVersion": 2,
  "mediaType": "application/vnd.oci.image.manifest.v1+json",
  "artifactType": "showcase/todo-service",
  "config": {
    "mediaType": "application/vnd.oci.empty.v1+json",
    "digest": "sha256:44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a",
    "size": 2,
    "data": "e30="
  },
  "layers": [
    {
      "mediaType": "application/octet-stream",
      "digest": "sha256:cc8ab19ee7e1f1f7d43b023317c560943dd2c15448ae77a83641e272bc7a5dbc",
      "size": 27352532,
      "annotations": {
        "org.opencontainers.image.title": "todo-service/todo-service.bin"
      }
    }
  ],
  "annotations": {
    "org.opencontainers.image.created": "2025-06-04T11:57:57Z"
  }
}
----

==== Discover the tree

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \
    ghcr.io/oras-project/oras:main \
    discover --format tree --plain-http \
    localhost:5000/todo-service:latest
localhost:5000/todo-service@sha256:fb1f02fff7f1406ae3aa2d9ebf3f931910b69e99c95e78e211037f11ec8f1eb6
----

There are many more helpful {orascmds}[commands] that can be used to interact with stored images,
other types of {blobs}[blobs] and also with supporting files.
Typically among these supporting are museum-less {helm}[Helm]-charts and also {sbom}[SBOM].

== What is an SBOM?

A *software bill of materials* or SBOM is a kind of inventory list of an artifact, which details
included software components and assists in securing the software supply chain.
This gets more and more attention as it should especially since the
{log4j}[log4j vulnerability] back then in 2020 and 2021.

There are different formats for SBOM files like {spdx}[SPDX] or {cyclondedx}[CycloneDX] and also
a broad range of tools that support one or more of them as input and output is available.

I am kind of fondfootnote:[Maybe I just like their mascots?] of Anchore with their tools
{syft}[syft] and {grype}[grype] and therefore the next examples are going to make use of both of
them.

=== Syfting through

Since my todo service is based on Golang syft can easily scan the source code and assemble our
SBOM

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \
    -v ./todo-service:/in \
    docker.io/anchore/syft:latest scan dir:/in -o cyclonedx-json=/workspace/sbom.json # <.>
 ✔ Indexed file system                                                                                                                                                                                                                                                    /in
 ✔ Cataloged contents                                                                                                                                                                                        86121fea66864109267c361a1fec880ab49dc5f619205b1f364ecb7ba31eb066
   ├── ✔ Packages                        [70 packages]
   ├── ✔ Executables                     [1 executables]
   ├── ✔ File digests                    [1 files]
   └── ✔ File metadata                   [1 locations]
[0000]  WARN no explicit name and version provided for directory source, deriving artifact ID from the given path (which is not ideal)
A newer version of syft is available for download: 1.26.1 (installed version is 1.26.0) # <.>
$ cat sbom.json | jq '.components | length' # <.>
71
----
<.> My pick is entirely based on the cool name though.
<.> Interesting since I am using the `latest` tag.
<.> Quite a lot of components..

=== Scanning the SBOM

Like Trivy, grype can easily be run from inside a container and start scanning:

[source,shell]
----
$ podman run --rm -v .:/workspace -it --name grype --network=host \
    docker.io/anchore/grype:latest sbom:/workspace/sbom.json
 ✔ Vulnerability DB                [updated]
 ✔ Scanned for vulnerabilities     [9 vulnerability matches]
   ├── by severity: 1 critical, 2 high, 6 medium, 0 low, 0 negligible
   └── by status:   9 fixed, 0 not-fixed, 0 ignored
NAME                        INSTALLED  FIXED-IN  TYPE       VULNERABILITY        SEVERITY  EPSS%  RISK
golang.org/x/crypto         v0.15.0    0.17.0    go-module  GHSA-45x7-px36-x8w8  Medium    98.45   36.5
golang.org/x/net            v0.18.0    0.23.0    go-module  GHSA-4v7x-pqxf-cx7m  Medium    98.35   33.4
golang.org/x/crypto         v0.15.0    0.31.0    go-module  GHSA-v778-237x-gjrc  Critical  96.91   32.6
google.golang.org/protobuf  v1.31.0    1.33.0    go-module  GHSA-8r3f-844c-mc37  Medium    46.14    0.1
github.com/jackc/pgx/v5     v5.4.3     5.5.4     go-module  GHSA-mrww-27vc-gghv  High      38.06    0.1
golang.org/x/crypto         v0.15.0    0.35.0    go-module  GHSA-hcg3-q754-cr77  High      15.90  < 0.1
golang.org/x/net            v0.18.0    0.38.0    go-module  GHSA-vvgc-356p-c3xw  Medium     5.05  < 0.1
golang.org/x/net            v0.18.0    0.36.0    go-module  GHSA-qxp5-gwg8-xv66  Medium     1.24  < 0.1
github.com/jackc/pgx/v5     v5.4.3     5.5.2     go-module  GHSA-fqpg-rq76-99pq  Medium      N/A    N/A
----

=== Uploading our SBOM

If we are content with the scanning result and I bet we arefootnote:[Not!] let us quickly add this
to our image:

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \
    ghcr.io/oras-project/oras:main \
    attach localhost:5000/todo-service:latest --plain-http \
    --artifact-type showcase/sbom \ # <.>
    sbom.json:application/vnd.cyclonedx+json
✓ Uploaded  sbom.json                                                                                                                                                                                                                                50.1/50.1 KB 100.00%    2ms
  └─ sha256:0690e255a326ee93c96bf1471586bb3bc720a1f660eb1c2ac64bbf95a1bd9693
✓ Exists    application/vnd.oci.empty.v1+json                                                                                                                                                                                                              2/2  B 100.00%     0s
  └─ sha256:44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a
✓ Uploaded  application/vnd.oci.image.manifest.v1+json                                                                                                                                                                                                 724/724  B 100.00%    3ms
  └─ sha256:5c6bb144aaed7d3e4eb58ac6bcdbf2a68d0409d5328f81c9d413e9301e2517a9
Attached to [registry] localhost:5000/todo-service@sha256:fb1f02fff7f1406ae3aa2d9ebf3f931910b69e99c95e78e211037f11ec8f1eb6
Digest: sha256:5c6bb144aaed7d3e4eb58ac6bcdbf2a68d0409d5328f81c9d413e9301e2517a9
----
<.> This gave me a bit of a headache, because Zot supports SBOM scanning and also propagates the results
on the web ui.
Unfortunately just for known media types and I wondered if I got the media type wrong: +
<https://github.com/project-zot/zot/issues/2415>
[source,golang]
----
// https://github.com/project-zot/zot/blob/main/pkg/extensions/search/cve/trivy/scanner.go#L278
func (scanner Scanner) isManifestScanable(digestStr string) (bool, error) {
...
    switch imageLayer.MediaType {
    case ispec.MediaTypeImageLayerGzip, ispec.MediaTypeImageLayer, string(regTypes.DockerLayer):
        continue
    default:
    return false, zerr.ErrScanNotSupported
...
}
----

=== Signing images

== Conclusion

All examples can be found here:

<https://github.com/unexist/showcase-oci-registries>

[bibliography]
== Bibliography
