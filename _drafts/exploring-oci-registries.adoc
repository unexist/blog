---
layout: post
title: Exploring OCI registries
description: This blog post demonstrates how ORAS can be used to leverage OCI-compliant registries to handle all kind of artifacts.
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: container oci oras cosign cyclodedx sbom showcase
categories: tech
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/exploring_oci_registries
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/exploring_oci_registries
endif::[]
:figure-caption!:
:table-caption!:
:page-liquid:

:podman: https://podman.io/
:oci: https://opencontainers.org/
:oras: https://oras.land/
:sbom: https://about.gitlab.com/blog/2022/10/25/the-ultimate-guide-to-sboms/
:harbor: https://goharbor.io/
:runtimespec: https://github.com/opencontainers/runtime-spec/blob/main/spec.md
:imagespec: https://github.com/opencontainers/image-spec/blob/main/spec.md
:distspec: https://github.com/opencontainers/distribution-spec/blob/main/spec.md
:github: https://github.com
:json: https://www.json.org/
:mediaspec: https://specs.opencontainers.org/image-spec/media-types/
:zotreg: https://zotregistry.dev/
:cyclondedx: https://cyclonedx.org/

Handling containers is probably something a modern developer can't and probably *should* not live
without anymore.
They provide flexibility, allow easy packaging and also sandboxing of stuff you might not want
to have installed on your machine.

Like so often in tech, using something successfully doesn't imply real understanding how it
works under the hood, but I lived quite happily with this black box and all greasy details
shrouded in mysteries hidden behind tooling like {podman}[Podman].
This changed, when I started looking for an artifact store for our firmware binary artifacts.
I quickly discovered there are many container registries available, but just a few stores for
_ordinary_ artifacts without spending large parts of our engineering budget on enterprise
license fees.
Asking my bubble, a good friend suggested to have a look at {oras}[ORAS], which leverages
{oci}[OCI]-compliant registries for exactly what I wanted to archive.
We are already using Harbor][], so moving other artifacts there as well directly aroused my
interest.

So over the course of this article we are going to dive into the container world with a short
primer of the duality of OCI, talk about basic usage and a few advanced points like {sbom}[SBOM]
and signing and conclude with my impression on the technology.

NOTE: The next section gives some brief details about what OCI is and what is inside of a container,
so if you are just here for examples of how to use ORAS please jump ahead and wait for us.

== Excursion: What is OCI?

Turns out the {oci}[Open Container Initiative (OCI)] isn't a single spec by itself, but rather
a governance body around several container formats and runtimes - namely:

- Runtime Specification ({runtimespec}[runtime-spec])
- Image Specification ({imagespec}[image-spec])
- Distribution Specification ({distspec}[distribution-spec])

The links lead to the related {github}[GitHub] projects in case you want to build your own
container engine, but I suggest we focus on *image-spec*, which lays out the structure in all gory
details.

=== Containers inside out

If you've dutifully studied the spec the overall structure of an actual container will probably
not surprise you.
They can be fetched with the help of tools like Podman and easily be dissect on the shell:

[source,shell]
----
$ podman save ghcr.io/oras-project/oras:main -o oras.tar
Copying blob 08000c18d16d done   |
...
Writing manifest to image destination
$ tar xvf oras.tar --one-top-level
08000c18d16dadf9553d747a58cf44023423a9ab010aab96cf263d2216b8b350.tar
...
manifest.json
repositories
$ tree oras
oras
├── 08000c18d16dadf9553d747a58cf44023423a9ab010aab96cf263d2216b8b350.tar
...
├── 29ec8736648c6f233d234d989b3daed3178a3ec488db0a41085d192d63321c72
    ├── json
    ├── layer.tar -> ../08000c18d16dadf9553d747a58cf44023423a9ab010aab96cf263d2216b8b350.tar
    └── VERSION
...
├── manifest.json
└── repositories

6 directories, 23 files
----

Following links in {json}[JSON]-files and digests is a bit cumbersome at least to me, so let us try arrows
instead.

== Containers mapped out

[plantuml]
----
'"!theme unexist from {{ site.asciidoctor_attributes.plantumldir }}

'skinparam linetype ortho
skinparam nodesep 20
skinparam ranksep 20

package "Index (5)" as index {
    json "Manifests" as index_manifests {
        [
            {
                "mediaType": "<back:wheat>application/vnd.oci.image.manifest.v1+json",
                "size": "<i>$(du --bytes manifest.json)",
                "digest": "sha256:<back:goldenrod><i>$(sha256 manifest.json)",
                "platform": {
                    "architecture": "amd64",
                    "os": "linux"
                }
            }
        ]
    }

    json "Annotations" as index_annotations {
        "blog.unexist.author": "unexist",
        "blog.unexist.title": "Exploring OCI registries"
    }
}

package "Blobs (1)" as blobs {
    file "Manifest amd64/linux" as blobs_manifest_amd64 #goldenrod
    file "Config amd64/linux" as blobs_config_amd64 #deepskyblue
    file "Layer 1" as blobs_l1 #palegreen
    file "Layer 2" as blobs_l2 #palegreen
    file "Layer n" as blobs_ln
}

package "Manifest (4)" as manifest {
    json "Config" as manifest_config {
        "mediaType": "<back:wheat>application/vnd.oci.image.config.v1+json",
        "size": "<i>$(du --bytes config.json)",
        "digest": "sha256:<back:deepskyblue><i>$(sha256 config.json)"
    }

    json "Layers (5)" as manifest_layers {
        [
            {
                "mediaType": "<back:wheat>application/vnd.oci.image.layer.v1.tar",
                "size": "<i>$(du --bytes layer1.tar)",
                "digest": "sha256:<i><back:palegreen>$(sha256 layer1.tar)"
            },
            {
                "mediaType": "application/vnd.oci.image.layer.v1.tar",
                "size": "<i>$(du --bytes layer2.tar)",
                "digest": "sha256:<i><back:palegreen>$(sha256 layer2.tar)"
            }
        ]
    }
}

package "Config (2)" as configs {
    json "Meta" as config_attrs {
        "created": "<i>$(date --iso-8601=ns)",
        "author": "unexist",
        "architecture": "amd64",
        "os": "linux"
    }

    json "rootfs (3)" as config_rootfs {
       "diff_ids": [
            "sha256:<i><back:palegreen>$(sha256 layer1.tar)",
            "sha256:<i><back:palegreen>$(sha256 layer2.tar)"
        ]
    }
}

' Arrows
manifest o-l-o blobs_manifest_amd64 #goldenrod
configs o-r-o blobs_config_amd64 #mediumpurple

config_rootfs -> blobs_l1
config_rootfs -> blobs_l2

manifest_layers -> blobs_l1
manifest_layers -> blobs_l2

' Global placement
index -[hidden]r-> blobs
index -[hidden]d-> manifest
manifest -[hidden]l-> blobs
blobs -[hidden]r-> configs

' Index
index_manifests -[hidden]d-> index_annotations

' Blobs
blobs_manifest_amd64 -[hidden]d-> blobs_config_amd64
blobs_config_amd64 -[hidden]d-> blobs_l1
blobs_l1 -[hidden]d-> blobs_l2
blobs_l2 -[hidden]d-> blobs_ln

' Manifests
manifest_config -[hidden]d-> manifest_layers

' Configs
config_attrs -[hidden]d-> config_rootfs
----
<1> *Blobs* is the main directory with all adressable filesystem layers and their related metadata
defined in the appropriate JSON files _config_ and _manifest_.
_The name of the layers are actually digests as well, but to make it easier to follow let us keep the
fancy numbers._
<2> *Config* contains entries like meta information about author as well as other runtime
information like environment variables, entrypoints, volume mounts etc. as well as infos about
specific hardware architecture and OS.
<3> *rootfs* contains an ordered list of the digests that compose the actual image.
<4> The *manifest* just links to the actual configugration by digest and to the layers.
<5> And finally the *index* includes all available manifests and also image annotations.

The remaining piece of the puzzle are the media types.

== What are mediatypes?

Among the long list of specs there is one we haven't covered so far and probably should - so please
welcome our last (promised) spec for today - the one about {mediaspec}[media types].

This is what allows us to be compatible to existing runtimes and also to swap out layers as long as
we are upright and set the appropriate media type.
There are several interesting ones which also ensure a certain behavior, but the specs are quite
generous and allow mostly arbitrary values, which are ignored when unsupported.

== Use-Cases

The next examples require a OCI-compatible registry and also accessible *oras* and *cosign*
binaries.
Installation can sometimes be a hassle, so we keep on relying on podman and the pretty well
supported {zotreg}[Zot Registry]:

=== Setting up Zot

The next command probably requires no further explanations besides what is inside of the
provided config.
Here we pretty much set just the essentials and also *deliberate* without any hardening for actual
logins.
Apart from setting pretty much defaults we also want to enable the web ui and the cve scanner - you
can find it here:

<https://github.com/unexist/showcase-oci-registries/blob/master/infrastructure/zot-registry/config.json>

[source,shell]
----
$ podman run --rm -it --name zot-registry -p 5000:5000 --network=host \
  -v ./infrastructure/zot-registry/config.json:/etc/zot/config.json \
  ghcr.io/project-zot/zot-linux-amd64:v2.1.2
----

=== Pushing a binary artifact

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \ <.>
    ghcr.io/oras-project/oras:main \
    push localhost:5000/todo-service:latest \
        --artifact-type showcase/todo \ <.>
        todo-service/todo-service.bin:application/octet-stream \
        --plain-http
✓ Uploaded  todo-service/todo-service.bin                                                                                                                                                                                                                                                                                                        26.1/26.1 MB 100.00%   34ms
  └─ sha256:cc8ab19ee7e1f1f7d43b023317c560943dd2c15448ae77a83641e272bc7a5dbc
✓ Uploaded  application/vnd.oci.empty.v1+json                                                                                                                                                                                                                                                                                                          2/2  B 100.00%    4ms
  └─ sha256:44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a
✓ Uploaded  application/vnd.oci.image.manifest.v1+json                                                                                                                                                                                                                                                                                             578/578  B 100.00%    7ms
  └─ sha256:bf34418c95a3f5d3c55eb2652daaa87fcf547d997e035401f1437aebe04d613a
Pushed [registry] localhost:5000/todo-service:latest
ArtifactType: showcase/todo
Digest: sha256:bf34418c95a3f5d3c55eb2652daaa87fcf547d997e035401f1437aebe04d613a
----
<.> The ORAS container allows us to call it this way and directly pass our arguments.
<.> Here we set our custom artifact type, to be able to distinguish it.

=== Pulling it back

Unfortunately and actually without surprise, Podman doesn't know our custom artifact-type and
hence refuses to do our bidding:

[source,shell]
----
$ podman pull localhost:5000/todo-service:latest
Trying to pull localhost:5000/todo-service:latest...
Error: parsing image configuration: unsupported image-specific operation on artifact with type "showcase/todo"
----

[NOTE]
====
If Podman cannot connect to your local registry and bails out with
`http: server gave HTTP response to HTTPS client` please make sure to add your *insecure* registry
to your _/etc/containers/registries.conf_ file:

[source,shell]
----
$ tail -n2 /etc/containers/registries.conf
[registries.insecure]
registries = ['localhost:5000']
----
====

=== Pull harder

Let us try again - this time with ORAS.

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \
    ghcr.io/oras-project/oras:main \
    pull localhost:5000/todo-service:latest --plain-http
✓ Pulled      todo-service/todo-service.bin                                                                                                                                                                                                                                                                                                      26.1/26.1 MB 100.00%   32ms
  └─ sha256:cc8ab19ee7e1f1f7d43b023317c560943dd2c15448ae77a83641e272bc7a5dbc
✓ Pulled      application/vnd.oci.image.manifest.v1+json                                                                                                                                                                                                                                                                                           578/578  B 100.00%   98µs
  └─ sha256:bf34418c95a3f5d3c55eb2652daaa87fcf547d997e035401f1437aebe04d613a
Pulled [registry] localhost:5000/todo-service:latest
Digest: sha256:bf34418c95a3f5d3c55eb2652daaa87fcf547d997e035401f1437aebe04d613a
$ tree todo-service
todo-service
└── todo-service.bin

1 directory, 1 file
----

=== Print the image manifest

There are several commands available to gather information about images on the registry:

[source,shell]
----
$ podman run --rm -v .:/workspace -it --network=host \
    ghcr.io/oras-project/oras:main \
    manifest fetch --pretty \
    localhost:5000/todo-service:latest --plain-http
{
  "schemaVersion": 2,
  "mediaType": "application/vnd.oci.image.manifest.v1+json",
  "artifactType": "showcase/todo",
  "config": {
    "mediaType": "application/vnd.oci.empty.v1+json",
    "digest": "sha256:44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a",
    "size": 2,
    "data": "e30="
  },
  "layers": [
    {
      "mediaType": "application/octet-stream",
      "digest": "sha256:cc8ab19ee7e1f1f7d43b023317c560943dd2c15448ae77a83641e272bc7a5dbc",
      "size": 27352532,
      "annotations": {
        "org.opencontainers.image.title": "todo-service/todo-service.bin"
      }
    }
  ],
  "annotations": {
    "org.opencontainers.image.created": "2025-06-02T13:05:34Z"
  }
}
----


=== Excursion: Using SBOM

== Conclusion

All examples can be found here:

<https://github.com/unexist/showcase-oci-registries>

[bibliography]
== Bibliography
