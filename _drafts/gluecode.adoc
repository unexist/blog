---
layout: post
title: Gluecode?
date: %%%DATE%%%
last_updated: %%%DATE%%%
author: Christoph Kappel
tags: cucumber karate showcase
categories: testing bdd showcase
toc: true
---
:imagesdir: /assets/images/gluecode.adoc

I am more and more interested in [acceptance testing][] lately and if you browse through the
posts of this blog you are going to find one or another post about the whole idea along with some
noteworthy tooling.

One aspect I haven't touched so far far is how do we bring the actual tests *and* the
[system under test][] (SUT) together and if we use code, where should it reside?

Let us start with a small recap, so we all are on the same page and than move on to the sparking
bits after that.

== A small recap

The general idea of [behavior-driven design][] is to consider a software component as a
**blackbox** and describe (and later verify) the observable behavior without any knowledge of
its internal workings or the chosen technology - this is in contrast to other tests, which follow
a **whitebox** approach.

Naturally, a [test-driven development][] approach works pretty well here, but there really is no
requirement to this or even to be standing on a green field.

When you are sitting in front of a huge pile of [line-through]#shi# code and are desperately
trying to figure out what it should do exactly, it even morel beneficial to explore the behavior
and document it - supported by actual examples.

NOTE: [Robert C. Martin][] calls these tests [characterization tests][] in his book
[Working Effectively With Legacy Code][].

So far the theory - example time!

== Use cases

The following use cases are again based on a simple todo application with a [REST][] endpoint to
create and manage todo entries - a complete description along with [OpenAPI][] can be found
[here][].

=== Use case #1: Create a todo with title and description

The creation is pretty straight forward, we just have to pass a `title` and a `description` over
to our endpoint and verify, if we receive the `id` of a newly created entry.

If we rephrase this to the lovely [Three R][] format (coined by [Connextra][]), we end up with
something like this:

----
As a user, I want to create a new todo entry with title and description, so that it is stored
with an unique ID for later retrieval.
----

Equipped with this, let us dive into how this can be done with [Cucumber][] and [Karate][].

==== Cucumber

A [Gherkin][] feature intentionally resembles the [Three R][] and can be easily translated into
_almost_ natural language:

[source,gherkin]
----
Feature: Create a todo

  Scenario Outline: Create a todo with title and description and check the id.
    Given I create a todo # <1>
    When its title is "<title>" # <2>
    And its description is "<description>"
    Then its id should be <id> # <3>

    Examples:
      | title  | description  | id |
      | title1 | description1 | 1  |
      | title2 | description2 | 2  |
----
<1> This describes who wants to do something. (`Role`)
<2> Next up is what is needed. (`Requirements`)
<3> And finally why.. (`Reason`)

Calling [Cucumber][] a simple pattern matcher probably doesn't live up to it, but for all practical
matters it is exactly that. (__Trust me on that - you can replace each of `given/when/then` with a
simple `*` and it still magically works__)

There are many different [language bindings][] available, but here we want to focus on the one for
the [JVM][]:

[source,java]
----
public class TodoSteps {
    private final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private RequestSpecification requestSpec;
    private TodoBase todoBase;
    private DueDate dueDate;

    @Before
    public void beforeScenario() {
        this.requestSpec = new RequestSpecBuilder()
                .setPort(8081)
                .setContentType(ContentType.JSON)
                .setAccept(ContentType.JSON)
                .build();
    }

    @Given("I create a todo") // <1>
    public void given_create_todo() {
        this.todoBase = new TodoBase();
        this.dueDate = new DueDate();
    }

    @When("its title is {string}") // <2>
    public void when_set_title(String title) {
        this.todoBase.setTitle(title);
    }

    @And("its description is {string}") // <3>
    public void and_set_description(String description) {
        this.todoBase.setDescription(description);
    }

    @Then("its id should be {int}") // <4>
    public void then_get_id(int id) {
        String location = given(this.requestSpec)
            .when()
                .body(this.todoBase)
                .post("/todo")
            .then()
                .statusCode(201)
            .and()
                .extract().header("location");

        assertThat(location.substring(location.lastIndexOf("/") + 1))
                .isEqualTo(Integer.toString(id));
    }
}
----
<1> On a match create a new Todo object.
<2> Set a title of our Todo object.
<3> Also set a description.
<4> And finally call the endpoint and assert whatever comes back.

There are probably no surprises here - so let's see how this can be done in [Karate][].

==== Karate

[Karate][] also relies on the [Gherkin][] language and I am most certain you will see similarities
here.
In contrast to the previous example with [Cucumber][] we don't have to write any [Java][] code
to get this running.
Under the hood [Karate][] uses full-fledged [html engine][] to run the actual tests and provides
many built-in tools for our tests:

[source,gherkin]
----
Feature: Create a todo

  Background:
    * url 'http://localhost:8081' # <1>

  Scenario Outline: Create a todo with title and description and check the id.
    Given path 'todo'
    And request
    """
    {
      "description": <description>,
      "done": true,
      "dueDate": {
        "due": "2021-05-07",
        "start": "2021-05-07"
      },
      "title": <title>
    }
    """
    When method post
    Then match header location ==  "#regex .*/todo/<id>"

    Examples:
      | title    | description    | id |
      | 'title1' | 'description1' | 1  |
      | 'title2' | 'description2' | 2  |
----

=== Use case #2: Create a todo with start and due date

==== Cucumber

[source,gherkin]
----
  Scenario Outline: Create a todo with start and due dates and check the status.
    Given I create a todo
    When it starts on "<start>"
    And it ends on "<due>"
    Then it should be marked as <status>

    Examples:
      | start      | due        | status  |
      | 2021-09-10 | 2022-09-10 | undone  |
      | 2021-09-10 | 2021-09-09 | done    |
----

[source,java]
----
public class TodoSteps {
    private final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private RequestSpecification requestSpec;
    private TodoBase todoBase;
    private DueDate dueDate;

    @Before
    public void beforeScenario() {
        this.requestSpec = new RequestSpecBuilder()
                .setPort(8081)
                .setContentType(ContentType.JSON)
                .setAccept(ContentType.JSON)
                .build();
    }

    @Given("I create a todo")
    public void given_create_todo() {
        this.todoBase = new TodoBase();
        this.dueDate = new DueDate();
    }

    @When("it starts on {string}")
    public void when_set_start_date(String datestr) {
        if (StringUtils.isNotEmpty(datestr)) {
            this.dueDate.setStart(LocalDate.parse(datestr, this.dtf));
        }
    }

    @And("it ends on {string}")
    public void and_set_due_date(String datestr) {
        if (StringUtils.isNotEmpty(datestr)) {
            this.dueDate.setDue(LocalDate.parse(datestr, this.dtf));
        }
    }

    @Then("it should be marked as {status}")
    public void then_get_status(boolean status) {
        this.todoBase.setDueDate(this.dueDate);

        assertThat(status).isEqualTo(this.todoBase.getDone());
    }

    @ParameterType("done|undone")
    public boolean status(String status) {
        return "done".equalsIgnoreCase(status);
    }
}
----

==== Karate

[source,gherkin]
----
  Scenario Outline: Create a todo with start and due dates and check the status.
    Given def createTodo =
    """
    function(args) {
      var TodoType = Java.type("dev.unexist.showcase.todo.domain.todo.Todo");
      var DueDateType = Java.type("dev.unexist.showcase.todo.domain.todo.DueDate");
      var DateTimeFormatterType = Java.type("java.time.format.DateTimeFormatter");
      var LocalDateType = Java.type("java.time.LocalDate");

      var dtf = DateTimeFormatterType.ofPattern("yyyy-MM-dd");

      var dueDate = new DueDateType();

      dueDate.setStart(LocalDateType.parse(args.startDate, dtf));
      dueDate.setDue(LocalDateType.parse(args.dueDate, dtf));

      var todo = new TodoType();

      todo.setDueDate(dueDate);

      return todo.getDone() ? "done" : "undone";
    }
    """
    When def result = call createTodo { startDate: <start>, dueDate: <due> }
    Then match result == "<status>"

    Examples:
      | start      | due        | status |
      | 2021-09-10 | 2022-09-10 | undone |
      | 2021-09-10 | 2021-09-09 | done   |
----

```
https://www.goodreads.com/en/book/show/44919
```

== Conclusion

I've added all the mentioned [Karate][] examples to my acceptance testing showcase and you can find
it in the usual place:

<https://github.com/unexist/showcase-acceptance-testing-quarkus>