---
layout: post
title: Gluecode?
date: %%%DATE%%%
last_updated: %%%DATE%%%
author: Christoph Kappel
tags: cucumber karate showcase
categories: testing bdd showcase
toc: true
---
:imagesdir: /assets/images/gluecode.adoc

[Acceptance testing][] is one of the things I am highly interested in and if you browse through the
posts of this blog you are going to find one or another post about the whole idea, some
noteworthy tools and of course, reporting.

One aspect I barely touched so far is how do we bring the actual behavioral tests and the
[system under test][] (SUT) together?

I'd say with glue - but let us set the stage first and talk about what we going to do.

== A small recap

The general idea of [behavior-driven design][] is to consider a software component as a
**blackbox** and describe (and later verify) the observable behavior without any knowledge of
its internal workings or the chosen technology - this is in contrast to other tests, which follow
a **whitebox** approach.

Naturally, a [test-driven development][] approach works pretty well here, but there really is no
requirement to this or to start from scratch - on a green field.

So even if our code already exists and you try to discover the behavior of our existing legacy
application, it is still beneficial to explore this behavior and even more important to create
a document, that describes what a piece of code is supposed to - supported by actual examples.

NOTE: These kind of tests are called [characterization tests][] in the book
[Working Effectively With Legacy Code][].

So far the theory - let us apply that to an example.

== Use cases

We start with a simple todo application and a [REST][] endpoint to create todo entries and to
interact with them.

=== Use case #1: Create a todo with title and description

The creation is pretty easy, we just have to pass a `title` and a `description` over to our
endpoint and verify, if we receive the `id` of a newly created entry.

In our first example we are going to use [Gherkin][], to create a natural language for our domain
for our domain experts and developers to understand each other.

NOTE: This concept is also called [Ubiquitous Language][] in the context of [Domain-driven Design][].

[source,gherkin]
----
Feature: Create a todo

  Scenario Outline: Create a todo with title and description and check the id.
    Given I create a todo
    When its title is "<title>"
    And its description is "<description>"
    Then its id should be <id>

    Examples:
      | title  | description  | id |
      | title1 | description1 | 1  |
      | title2 | description2 | 2  |
----

I think this is pretty straight forward and in this post we want to focus on the overall idea
of gluecode and not the actual [Gherkin][] format.
So if you struggle to understand the lines above, please have a look at this [primer][] first.

==== Cucumber

Calling [Cucumber][] a simple pattern matcher probably doesn't live up to it, but for all practical
matters it is exactly that.
In your code you basically tell it, what method has to be called whenever a given line appears in
your feature files.

There are many different [language bindings][] available, but again let us focus on the one for
the [JVM][]:

[source,java]
----
public class TodoSteps {
    private final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private RequestSpecification requestSpec;
    private TodoBase todoBase;
    private DueDate dueDate;

    @Before
    public void beforeScenario() {
        this.requestSpec = new RequestSpecBuilder()
                .setPort(8081)
                .setContentType(ContentType.JSON)
                .setAccept(ContentType.JSON)
                .build();
    }

    @Given("I create a todo") // <1>
    public void given_create_todo() {
        this.todoBase = new TodoBase();
        this.dueDate = new DueDate();
    }

    @When("its title is {string}") // <2>
    public void when_set_title(String title) {
        this.todoBase.setTitle(title);
    }

    @And("its description is {string}") // <3>
    public void and_set_description(String description) {
        this.todoBase.setDescription(description);
    }

    @Then("its id should be {int}") // <4>
    public void then_get_id(int id) {
        String location = given(this.requestSpec)
            .when()
                .body(this.todoBase)
                .post("/todo")
            .then()
                .statusCode(201)
            .and()
                .extract().header("location");

        assertThat(location.substring(location.lastIndexOf("/") + 1))
                .isEqualTo(Integer.toString(id));
    }
}
----

==== Karate

[source,gherkin]
----
Feature: Create a todo

  Background:
    * url 'http://localhost:8081'

  Scenario Outline: Create a todo with title and description and check the id.
    Given path 'todo'
    And request
    """
    {
      "description": <description>,
      "done": true,
      "dueDate": {
        "due": "2021-05-07",
        "start": "2021-05-07"
      },
      "title": <title>
    }
    """
    When method post
    Then match header location ==  "#regex .*/todo/<id>"

    Examples:
      | title    | description    | id |
      | 'title1' | 'description1' | 1  |
      | 'title2' | 'description2' | 2  |
----

=== Use case #2: Create a todo with start and due date

[source,gherkin]
----
  Scenario Outline: Create a todo with start and due dates and check the status.
    Given I create a todo
    When it starts on "<start>"
    And it ends on "<due>"
    Then it should be marked as <status>

    Examples:
      | start      | due        | status  |
      | 2021-09-10 | 2022-09-10 | undone  |
      | 2021-09-10 | 2021-09-09 | done    |
----

==== Cucumber

[source,java]
----
public class TodoSteps {
    private final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private RequestSpecification requestSpec;
    private TodoBase todoBase;
    private DueDate dueDate;

    @Before
    public void beforeScenario() {
        this.requestSpec = new RequestSpecBuilder()
                .setPort(8081)
                .setContentType(ContentType.JSON)
                .setAccept(ContentType.JSON)
                .build();
    }

    @Given("I create a todo")
    public void given_create_todo() {
        this.todoBase = new TodoBase();
        this.dueDate = new DueDate();
    }

    @When("it starts on {string}")
    public void when_set_start_date(String datestr) {
        if (StringUtils.isNotEmpty(datestr)) {
            this.dueDate.setStart(LocalDate.parse(datestr, this.dtf));
        }
    }

    @And("it ends on {string}")
    public void and_set_due_date(String datestr) {
        if (StringUtils.isNotEmpty(datestr)) {
            this.dueDate.setDue(LocalDate.parse(datestr, this.dtf));
        }
    }

    @Then("it should be marked as {status}")
    public void then_get_status(boolean status) {
        this.todoBase.setDueDate(this.dueDate);

        assertThat(status).isEqualTo(this.todoBase.getDone());
    }

    @ParameterType("done|undone")
    public boolean status(String status) {
        return "done".equalsIgnoreCase(status);
    }
}
----

==== Karate

[source,gherkin]
----
  Scenario Outline: Create a todo with start and due dates and check the status.
    Given def createTodo =
    """
    function(args) {
      var TodoType = Java.type("dev.unexist.showcase.todo.domain.todo.Todo");
      var DueDateType = Java.type("dev.unexist.showcase.todo.domain.todo.DueDate");
      var DateTimeFormatterType = Java.type("java.time.format.DateTimeFormatter");
      var LocalDateType = Java.type("java.time.LocalDate");

      var dtf = DateTimeFormatterType.ofPattern("yyyy-MM-dd");

      var dueDate = new DueDateType();

      dueDate.setStart(LocalDateType.parse(args.startDate, dtf));
      dueDate.setDue(LocalDateType.parse(args.dueDate, dtf));

      var todo = new TodoType();

      todo.setDueDate(dueDate);

      return todo.getDone() ? "done" : "undone";
    }
    """
    When def result = call createTodo { startDate: <start>, dueDate: <due> }
    Then match result == "<status>"

    Examples:
      | start      | due        | status |
      | 2021-09-10 | 2022-09-10 | undone |
      | 2021-09-10 | 2021-09-09 | done   |
----

```
https://www.goodreads.com/en/book/show/44919
```

== Conclusion

I've added all the mentioned [Karate][] examples to my acceptance testing showcase and you can find
it in the usual place:

<https://github.com/unexist/showcase-acceptance-testing-quarkus>