---
layout: post
title: Decision records
description: This blog post summarizes my experience with architecture decision records (ADR), introduces technical debt records (TDB) and demonstrates how everything can be combined.
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: adr tdr asciidoc markdown showcase
categories: documentation myself
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/decision_records
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/decision_records
endif::[]
:figure-caption!:
:table-caption!:
:page-liquid:

:1: https://github.com/unexist/record-tools
:2: https://github.com/unexist/adr-tools
:3: https://github.com/npryce/adr-tools
:4: https://github.com/ms1963/TechnicalDebtRecords
:5: https://github.com/ms1963
:6: https://github.com/npryce

I can probably cite myself from this blog, but writing documentation (not necessarily good
documentation, but any at all) is really difficult and keeping it up-to-date nigh on impossible.
To ease the pain, some clever people invented tools to write [documentation-as-code], so docs can
co-exist next to the source and have a better chance of being touched, whenever something is
changed.

Based on my personal experience I can say the same is true for any kind of project decisions and
good luck finding any hint about them.

When I first heard about
{{ site.url }}{% post_url 2020-09-15-architecture-decisions %}[architecture decisions] I was
directly
intrigued, but it took a while for me to actually see the real benefit of them.

It never came to my mind, but why should we stop here?

== Technical Debts Records

[Michael Stal] pretty much got the gist of it and his suggestion is to handle [technical debts] in
the same lieu as architecture decisions.

- Documented as code
- Well placed next to the actual code or any other kind of source code repository
- With some mandatory fields and an open format as a guide rail.

In comparison with architecture decision records, the format of these new records (especially since
it is [Markdown]) looks a bit different, but we are going to cover that later on.

NOTE: I included the descriptions of the fields in the actual document, just because I cannot
explain the fields any better.

[source,markdown]
----
Technical Debt Record
====================

Title:
------
A concise name for the technical debt.

Author:
-------
The individual who identified or is documenting the debt.

Version:
--------
The version of the project or component where the debt exists.

Date:
-----
The date when the debt was identified or recorded.

State:
------
The current workflow stage of the technical debt (e.g., Identified, Analyzed, Approved, In Progress, Resolved, Closed, Rejected).

Relations:
----------
Links to other related TDRs to establish connections between different debt items.

Summary:
--------
A brief overview explaining the nature and significance of the technical debt.

Context:
--------
Detailed background information, including why the debt was incurred (e.g., time constraints, outdated technologies).

Impact:
-------
Technical Impact:
- How the debt affects system performance, scalability, maintainability, etc.

Business Impact:
- The repercussions on business operations, customer satisfaction, risk levels, etc.

Symptoms:
---------
Observable signs indicating the presence of technical debt (e.g., frequent bugs, slow performance).

Severity:
---------
The criticality level of the debt (Critical, High, Medium, Low).

Potential Risks:
----------------
Possible adverse outcomes if the debt remains unaddressed (e.g., security vulnerabilities, increased costs).

Proposed Solution:
-------------------
Recommended actions or strategies to resolve the debt.

Cost of Delay:
---------------
Consequences of postponing the resolution of the debt.

Effort to Resolve:
-------------------
Estimated resources, time, and effort required to address the debt.

Dependencies:
-------------
Other tasks, components, or external factors that the resolution of the debt depends on.

Additional Notes:
-----------------
Any other relevant information or considerations related to the debt.
----

He also provides [tooling] along with the definition, which is quite nice for a starter.

== Record tools

During the course of the last few years I played with the original [adr-tools] based on the  work
of its inventor [Nat Pryce].
I added some more features like the pending [AsciiDoc] support, added a database layer to speed up
the generation and added simple rss/atom feeds.

== Records and culture

== Example

The following example demonstrates how we actually use the records and contains all the bolts
and glue to deploy rendered versions to your own [Confluence] instance, which unfortunately
always pays off to increase the targeted non-tech-savy audience.

Our example come with one record of each type and the decision to switch to the new format.

[source,asciidoc]
----
= 1. Record architecture decisions

:1: https://unexist.blog/documentation/myself/2024/10/22/decision-records.html

|===
| Proposed Date: | 2024-10-22
| Decision Date: | 2024-10-22
| Proposer:      | Christoph Kappel
| Deciders:      | Christoph Kappel
| Status:        | accepted
| Issues:        | none
| References:    | none
| Priority:      | high
|===

NOTE: *Status types:* drafted | proposed | rejected | accepted | deprecated | superseded +
      *Priority:* low | medium | high

== Context

We need to record the architectural decisions made on this project.

== Proposed Solution

Architecture Decision Records as {1}[summarised by Christoph] might help us as a format.

== Decision

We will use Architecture Decision Records.

== Consequences

None foreseeable.

== Further Information

== Comments
----

There are several options from here on:

- Calling the [AsciiDoc CLI] manually, which is perfectly capable of generating all of the documents
- Relying on [Maven], which is used anyway with the [Confluence Publisher] plugin

Since the [Makefile] already packages the commands necessary for Maven, so we are going to do it
based on the good ol' CLI:

[source,shell]
----
$ hg clone https://hg.unexist.dev/record-tools # <1>
...
$ cd record-tools/example
$ ../src/record-adr generate database # <2>
$ ../src/record-adr generate index > _adr_autogen.adoc # <3>
$ asciidoctor -D architecture-decision-records src/site/asciidoc/architecture-decision-records/*.adoc # <4>
$ asciidoctor -D . -I architecture-decision-records /site/asciidoc/architecture-decision-records.adoc # <3>
$ asciidoctor -r asciidoctor-pdf -b pdf -D . src/site/asciidoc/architecture-decision-records.adoc # <5>
----
<1> OR: git clone <https://github.com/unexist/record-tools>
<2> Generate the database for both types
<3> Generate a neat index page for both types
<4> Render the actual documents now
<5> Optional step - just in case a PDF version is required

Once rendered the pages should look like this:

.Index page
image::index-page.png[]

.ADR page
image::adr-page.png[]

== Conclusion

All examples can be found here:

<https://github.com/unexist/record-tools>

[bibliography]
== Bibliography
