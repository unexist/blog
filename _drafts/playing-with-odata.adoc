---
layout: post
title: Playing with OData
description: This blog introduces OData and summarizes its main similarities and differences to plain REST.
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: rest odata showcase
categories: tech
toc: true

---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/playing_with_odata
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/playing_with_odata
endif::[]
:figure-caption!:
:table-caption!:

////
https://www.sap.com/products/technology-platform.html
https://olingo.apache.org/
https://www.mydbsync.com/blogs/odata-and-rest-apis-a-comparison
https://restfulapi.net/
https://learn.microsoft.com/en-us/openspecs/dev_center/ms-devcentlp/1c24c7c8-28b0-4ce1-a47d-95fe1ff504bc?redirectedfrom=MSDN
////

Last year I briefly dived into the world of [SAP][] and its new [Business Technology Platform][]
(BTP) and tried to make sense of everything there.
During that time I discovered [OData][] is the communication protocol by choice and wondered about
its relationship to traditional [REST][].

So during the course of this blog post we are going to have a look at OData, compare it to REST
and look at examples of a rudimentary implementation based on the projects [Apache Olingo][] and
our good fellow [Quarkus][].

Before we can actually start, let us quickly recap what REST actually is.

== What is REST?

[Representational State Transfer][] (or REST) is an _architecture style_ originated from the
doctoral thesis by [Roy Fielding].

There is lots of good documentation about the general ideas, but the key takeaways for us are
following six easy principles:

|====
| *Uniform interface* | Interfaces must be unique identifiable, self-descriptive and have a uniform
representation
| *Client-Server* | [Separation of concern][] allows client and server to evolve independently
| *Stateless* | Each request must contain all the necessary information to handle it
| *Cachable* | A response can either be re-used (cached) or marked as non-reusable (non-cachable)
| *Layered System* | Hierarchical components cannot see beyond their immediate layer
| *Code on demand* (optional) | Client functionality can be extended by downloading and executing
scripts or applets
|====

Together the are the foundation of easy communication between web services with the well-known
example [Hypertext Transfer Protocol][] (or HTTP).

== And what is OData?

Open Data protocol (or OData) is a standardized _application protocol_ for [RESTful][] services.
Initially been created by [Microsoft][] in 2007, it was later included in the
[Microsoft Open Specification Promise][] and therefore opened for everyone else to use freely.

The protocol adheres to following principles and specifications:

- OData *MUST* follow REST-principles *UNLESS* there is a good reason not to
- OData Services *MUST* support ATOM encoding
- OData services *SHOULD* support JSON encoding

=== Service documents

A good starting point for interaction with every OData service is the *atom service document* at
the root of it.
It can be requested with a simple call with e.g. [curl][] and includes a brief list of the
names and feeds handled by the service:

[source,bash]
----
$ curl -s -H "accept: application/json" http://localhost:8080/odata/ | jq .
{
  "@odata.context": "$metadata",
  "value": [
    {
      "name": "Todos",
      "url": "Todos"
    },
    {
      "name": "Tasks",
      "url": "Tasks"
    }
  ]
}
----

If you require more details the next best option is the *metadata document*, which
contains a complete description of the feeds, types, properties and relationships exposed
by this service.

In case you have wondered about the particular format of the previous document, the next
own follows suit, but includes more objects and probably justifies some explanations in
advance.
The general format is called [Entity Data Model][] (or EDM respectively EDMX
if you insist on [XML][]) and mainly consists of these types:

|====
| *Entity types* | Domain objects with a key, properties and relationships - like [Todo][]
| *Complex types* | Keyless value types belonging to an entity
| *Entity sets* | Aggregate entities of a given type
|====

The output can be pretty long, but a shorted version of the Todo entity looks like this in
[JSON][]:

[source,bash]
----
$ curl -s http://localhost:8080/odata/$metadata | jq .
{
  "$Version": "4.01",
  "OData.Todo": {
    "Todo": {
      "$Kind": "EntityType",
      "$Key": [
        "ID"
      ],
      "ID": {
        "$Type": "Edm.Int32" # <1>
      },
      "Title": {
        "$Type": "Edm.String"
      },
      "Description": {
        "$Type": "Edm.String"
      },
      "Tasks": { # <2>
        "$Kind": "NavigationProperty", # <3>
        "$Type": "OData.Todo.Task",
        "$Collection": true,
        "$Partner": "Todo",
        "$ContainsTarget": true
      }
    },
...
    "Container": { # <4>
      "$Kind": "EntityContainer",
      "Todos": {
        "$Kind": "EntitySet",
        "$Type": "OData.Todo.Todo",
        "$NavigationPropertyBinding": {
          "Tasks": "Tasks"
        }
      },
...
    }
  }
}
----
<1> Primitives and basic types
<2> Tasks is an embedded entity type
<3> Navigational properties allow access to related entities
<4> The enclosing container that holds the sets and imports

Next up we are going to see how the service can actually be queries for data.

=== Query, Filter, Expand and Order

OData provides by default lots of different ways to query for the actual data of
the service.

Listing all data can be archived by this easy call:

[source,bash]
----
$ curl -s http://localhost:8080/odata/Todos | jq .
{
  "@odata.context": "$metadata#Todos",
  "value": [
    {
      "ID": 1,
      "Title": "Todo string",
      "Description": "Todo string"
    }
  ]
}
----

Querying for more specific data can be done either by key properties:

[source,bash]
----
$ curl -s http://localhost:8080/odata/Todos(1) | jq .
{
  "@odata.context": "$metadata#Todos/$entity",
  "ID": 1,
  "Title": "Todo string",
  "Description": "Todo string"
}
----

Or more generally by all kind of properties directly via URL:

[source,bash]
----
$ curl -s http://localhost:8080/odata/Todos(ID=1) | jq .
{
  "@odata.context": "$metadata#Todos/$entity",
  "ID": 1,
  "Title": "Todo string",
  "Description": "Todo string"
}
----

System queries allow further control of the amount and order of the data and
can be used in the used manner.

Counting the actual data can be done with `$count`:

[source,bash]
----
$ curl -s http://localhost:8080/odata/Todos?\$count=true | jq .
{
  "@odata.context": "$metadata#Todos",
  "@odata.count": 2, # <1>
  "value": [
    {
      "ID": 1,
      "Title": "Todo string",
      "Description": "Todo string"
    },
    {
      "ID": 2,
      "Title": "Todo string",
      "Description": "Todo string"
    }
  ]
}
----
<1> The count of items is included at the root level of the document

Further limiting the data can be done via `$top` and `$skip`:

[source,bash]
----
$ curl -s http://localhost:8080/odata/Todos?\$skip=1 | jq .
{
  "@odata.context": "$metadata#Todos",
  "value": [
    {
      "ID": 1,
      "Title": "Todo string",
      "Description": "Todo string"
    }
  ]
}
$ curl -s http://localhost:8080/odata/Todos?\$top=1 | jq .
{
  "@odata.context": "$metadata#Todos",
  "value": [
    {
      "ID": 2,
      "Title": "Todo string",
      "Description": "Todo string"
    }
  ]
}
----

And limiting the number of actual properties can be done with `$select`:

[source,bash]
----
$ curl -s http://localhost:8080/odata/Todos(ID=1)?\$select=Title | jq .
{
  "@odata.context": "$metadata#Todos(ID,Title)/$entity",
  "@odata.id": "Todos(1)",
  "ID": 1, # <1>
  "Title": "Todo string"
}
----
<1> This doesn't apply to key properties; they are always included.

Our service document from above included the navigational properties Tasks and
this can be used to also request related entities and expand them via `$expand`:

[source,bash]
----
$ curl -s http://localhost:8080/odata/Todos(ID=1)?\$expand=Tasks | jq .
{
  "@odata.context": "$metadata#Todos(Tasks())/$entity",
  "ID": 1,
  "Title": "Todo string",
  "Description": "Todo string",
  "Tasks": [
    {
      "ID": 1,
      "TodoID": 1,
      "Title": "Task string",
      "Description": "Task string"
    }
  ]
}
----

== Conclusion

All examples can be found here:

<https://github.com/unexist/showcase-odata-quarkus>