---
layout: post
title: Playing with OData
description: This blog introduces OData and summarizes its main similarities and differences to plain REST.
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: rest odata showcase
categories: tech
toc: true

---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/playing_with_odata
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/playing_with_odata
endif::[]
:figure-caption!:
:table-caption!:

////
https://www.sap.com/products/technology-platform.html
https://olingo.apache.org/
https://www.mydbsync.com/blogs/odata-and-rest-apis-a-comparison
https://restfulapi.net/
https://learn.microsoft.com/en-us/openspecs/dev_center/ms-devcentlp/1c24c7c8-28b0-4ce1-a47d-95fe1ff504bc?redirectedfrom=MSDN
////

Last year I briefly dived into the world of [SAP][] and its new [Business Technology Platform][]
(BTP) and tried to make sense of everything there.
During that time I discovered [OData][] is the communication protocol by choice and wondered about
its relationship to traditional [REST][].

So during the course of this blog post we are going to have a look at OData, compare it to REST
and look at examples of a rudimentary implementation based on the projects [Apache Olingo][] and
our good fellow [Quarkus][].

Before we can actually start, let us quickly recap what REST actually is.

== What is REST?

[Representational State Transfer][] (or REST) is an _architecture style_ originated from the
doctoral thesis by [Roy Fielding].

There is lots of good documentation about the general ideas, but the key takeaways for us are
following six easy principles:

|====
| *Uniform interface* | Interfaces must be unique identifiable, self-descriptive and have a uniform
representation
| *Client-Server* | [Separation of concern][] allows client and server to evolve independently
| *Stateless* | Each request must contain all the necessary information to handle it
| *Cachable* | A response can either be re-used (cached) or marked as non-reusable (non-cachable)
| *Layered System* | Hierarchical components cannot see beyond their immediate layer
| *Code on demand* (optional) | Client functionality can be extended by downloading and executing
scripts or applets
|====

Together the are the foundation of easy communication between web services with the well-known
example [Hypertext Transfer Protocol][] (or HTTP).

== And what is OData?

Open Data protocol (or OData) is a standardized _application protocol_ for [RESTful][] services.
Initially been created by [Microsoft][] in 2007, it was later included in the
[Microsoft Open Specification Promise][] and therefore opened for everyone else to use freely.

The protocol adheres to following principles and specifications:

- OData *MUST* follow REST-principles *UNLESS* there is a good reason not to
- OData Services *MUST* support ATOM encoding
- OData services *SHOULD* support JSON encoding

=== Concepts and data models

A core concept of the OData protocol is the [Entity Data Model] or EDM, which is the used to
describe the served data via a metadata document.

This document contains following types:

|====
| *Entity type | Domain objects with their properties like Todo
| *Complex types* | Types that are included into other ones
| *Entity sets* | Aggregate entities of a given type
|====

OData uses Atom or JSON to define the data schema, and it provides two important models for the
management of data.

They are:

|====
| Entity Data Model or EDM | This is an abstract data model that *MUST* be used to describe the
data exposed by the service
| Service Model | This includes two static resources to provide information about the served data
and a set of dynamic resources to offers data management capabilities
|====

=== Metadata

=== Query, Filter, Expand

== Conclusion

All examples can be found here:

<https://github.com/unexist/showcase-odata-quarkus>