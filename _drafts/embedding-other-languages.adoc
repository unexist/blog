---
layout: post
title: Embedding other languages
description: TBD
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: showcase extism rust lua ruby
categories: tech story
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/embedding_other_languages
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/embedding_other_languages
endif::[]
:figure-caption!:
:table-caption!:
:page-liquid:
:source-highlighter: highlight.js

:deskbar: https://sourceforge.net/projects/deskbar/
:subtle: https://github.com/unexist/subtle
:subtle-rs: https://github.com/unexist/subtle-rs
:touchjs: https://github.com/unexist/touchjs
:rubtle: https://github.com/unexist/rubtle
:extism: https://extism.org/
:wasm: https://webassembly.org/
:lua: https://www.lua.org/
:ruby: https://www.ruby-lang.org/en/
:foss: https://en.wikipedia.org/wiki/Free_and_open-source_software
:github: https://github.com/
:codeberg: https://codeberg.org/

:ilities: https://en.wikipedia.org/wiki/List_of_system_quality_attributes
:maintainability: https://en.wikipedia.org/wiki/Maintainability
:extensibility: https://en.wikipedia.org/wiki/Extensibility
:wikipedia: https://en.wikipedia.org

:hackernews: https://news.ycombinator.com/
:clang: https://en.wikipedia.org/wiki/C_(programming_language)
:sharedobj: https://en.wikipedia.org/wiki/Shared_library
:segfault: https://en.wikipedia.org/wiki/Segmentation_fault
:dlopen: https://man7.org/linux/man-pages/man3/dlopen.3.html
:dlsym: https://man7.org/linux/man-pages/man3/dlsym.3.html
:setjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:longjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:goto: https://learn.microsoft.com/en-us/cpp/c-language/goto-and-labeled-statements-c
:acpi: https://en.wikipedia.org/wiki/ACPI

There are many qualities modern software [line-through]#has to# *should* address, especially when this is part of your
daily job.
Among the long list of {ilities}[-ilities], some of them are pretty self-explaining like
{maintainability}[maintainability], but others can be a tad more interesting like {extensibility}[extensibility].

How a certain quality is best achieved depends, like so often, on of a plethora of things, but let us pick a fun one
for the course of this post.
According to {wikipedia}[Wikipedia] extensibility revolves around future growth and also proper design to make this
possible, but also mentions scripting languages in the black box part.

To me future growth and proper design don't sound like fun in early 2026, therefore scripting languages here we come.

image::go_wrong.png[]

== Barebone

The year is 2004 and your project is obviously written in {clang}[C], so
the only real thing is to accept contribution in the form of even more C.
Since integration and compiling the whole project from scratch everytime is quite annoying, you design your own plugin
system with your good old buddies `dlopen` and `dlsym`:

.{deskbar}[Deskbar]/deskbar/plug.c:97
[source,c]
----
DbPlugElement *element = NULL;

element = (DbPlugElement *) malloc (sizeof (DbPlugElement));

snprintf (buf, sizeof (buf), "%s/%s.so", PLUGIN_DIR, file);

element->handle = dlopen (buf, RTLD_LAZY); // <.>

if ((err = dlerror ())) // <.>
        {
                db_log_err ("Cannot load plugin `%s'\n", file);
                db_log_debug ("dlopen (): %s\n", err);

                free (element);

                return;
        }

/* Get entrypoint and call it */
entrypoint      = dlsym (element->handle, "db_plug_init"); // <.>
element->data   = (*entrypoint) (); // <.>
----
<.> Load a named {sharedobj}[shared object] from path with {dlopen}[dlopen]
<.> There is apparently a third buddy, rarely mentioned at all
<.> Find the address of a named entrypoint with {dlsym}[dlsym]
<.> Execute the entrypoint for profit


This opens some new ways of enriching your software and from your perspective it bases on an understandable and
approachable API.

.{deskbar}[Deskbar]/plugins/battery.c:58+107
[source,c]
----
void
battery_update (void) // <.>
{
        int capacity    = 0,
        percent         = 0;

        char buf[100], state[20];

        /* Get battery info */
        if (!fd1)
                {
                        snprintf (buf, sizeof (buf), "/proc/acpi/battery/BAT%d/state", bat_slot);

                        fd1 = fopen (buf, "r");

                        memset (buf, 0, sizeof (buf));
                }
        else
            fseek (fd1, 0, SEEK_SET);
...
}

...

static DbPlug plugin =
{
        "Battery",       /* Plugin name */
        battery_create,  /* Plugin create function */
        battery_update,  /* Plugin update function */
        battery_destroy, /* Plugin destroy function */

        &data,           /* Plugin data */
        NULL,            /* Plugin format */

        3600             /* Plugin update interval */
};

DbPlug *
db_plug_init (void)
{
        plug = &plugin; // <.>

        return (&plugin);
}
----
<.> This is just an excerpt, but the plugin relies on the {acpi}[ACPI] interface to extract the battery stats
<.> Here we just pass a struct with function pointers to call the plugin

The learning curve is steep, and you quickly realize allowing custom code offers lots of freedom to enhance the
software, but like so often with double-edged sword, there is an.. ehm another sharp edge?
{segfault}[Segmentation faults], the bane of software engineering, don't make halt inside plugins like they should, but
they wipe the board and kill the entire application!

Shocked as you are, you grab your dusty C-bible and look for ways to mitigate this, since it goes without question you
don't want to violate the famous saying:

[quote,Linus Torvals,https://www.shutupmauro.com/]
[line-through]#Mauro, SHUT THE FUCK UP!# +
WE DO NOT BREAK USERSPACE!

Taking this advice by heart, you basically dive into the book and read on.

image::few_hours_later.png[]

Right there, in the forbidden section of the book, you stumble upon another pair of
buddies - `setjmp` and `longjmp`:

.{deskbar}[Deskbar]/deskbar/plug.c:32
[source,c]
----
if (setjmp (env) == 0) // <.>
        plugfunc ();
else
        {
                db_log_mesg ("Ayyyee! Segmentation fault in plugin %s!\n",
                                                                 element->data->name); // <.>
                db_log_debug ("Call to %s () failed\n", name);
                db_plug_unload (element);

                return (1);
        }
----
<.> {setjmp}[setjmp] is a bit arcane magic, but essentially sets a return markerfootnote:[Kind of a {goto}[goto label]] on the stack
<.> Well, different times back then..

.{deskbar}[Deskbar]/deskbar/sig.c:35
[source,c]
----
case SIGSEGV:
        longjmp (env, 1); // <.>

        db_log_debug ("Something went wrong! Segmentation fault!\n");
        db_sig_destroy ();

        abort ();
break;
----
<.> Once a segmentation fault occurs, unwind the stack with {longjmp}[longjmp] until the previous marker has been found
(if any) and try again

Once in place you feel content with the solution, reflect shortly on the impacts and release it to the wild.

|===
| Ease of use | Richness of API | Language agnostic | Error handling

| Requires compilation and linking
| Language + host provided
| No, requires plugins to be in Cfootnote:[Technically everything that can be linked, so other languages might actually be possible here]
| Arcane - requires stack unwinding
|===

== Scripting languages

Still happy with the success of the previous project, you think the previous great thing is lacking in design and
ambition and you devise something new.


|===
| Ease of use | Richness of API | Language agnostic | Error handling
|===

== Webassembly

|===
| Ease of use | Richness of API | Language agnostic | Error handling
|===

== Conclusion

The list of examples is quite long, but please help yourself:

- <{deskbar}>
- <{subtle}>
- <{subtle-rs}>
- <{touchjs}>
- <{rubtle}>

[bibliography]
== Bibliography
