---
layout: post
title: Embedding other languages
description: TBD
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: showcase extism rust lua ruby
categories: tech story
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/embedding_other_languages
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/embedding_other_languages
endif::[]
:figure-caption!:
:table-caption!:
:page-liquid:
:source-highlighter: highlight.js

:subtle-rs: https://github.com/unexist/subtle-rs
:touchjs: https://github.com/unexist/touchjs
:rubtle: https://github.com/unexist/rubtle
:extism: https://extism.org/
:wasm: https://webassembly.org/

:ilities: https://en.wikipedia.org/wiki/List_of_system_quality_attributes
:maintainability: https://en.wikipedia.org/wiki/Maintainability
:correctness: https://en.wikipedia.org/wiki/Correctness_(computer_science)
:extensibility: https://en.wikipedia.org/wiki/Extensibility
:wikipedia: https://en.wikipedia.org
:foss: https://en.wikipedia.org/wiki/Free_and_open-source_software
:xlib: https://en.wikipedia.org/wiki/Correctness_(computer_science)
:deskbar: https://sourceforge.net/projects/deskbar/
:gkrellm: https://gkrellm.srcbox.net/
:clang: https://en.wikipedia.org/wiki/C_(programming_language)
:sourceforge: https://sourceforge.net/
:deskbarsf: https://deskbar.sourceforge.net
:autotools: https://en.wikipedia.org/wiki/GNU_Autotools
:linker: https://en.wikipedia.org/wiki/Linker_(computing)
:sharedobj: https://en.wikipedia.org/wiki/Shared_library
:dlopen: https://man7.org/linux/man-pages/man3/dlopen.3.html
:dlsym: https://man7.org/linux/man-pages/man3/dlsym.3.html
:convention: https://en.wikipedia.org/wiki/Convention_over_configuration
:acpi: https://en.wikipedia.org/wiki/ACPI
:segfault: https://en.wikipedia.org/wiki/Segmentation_fault
:torvalds: https://en.wikipedia.org/wiki/Linus_Torvalds
:rust: https://rust-lang.org/
:setjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:longjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:goto: https://learn.microsoft.com/en-us/cpp/c-language/goto-and-labeled-statements-c
:signal: https://man7.org/linux/man-pages/man7/signal.7.html
:subtle: https://github.com/unexist/subtle
:lua: https://www.lua.org/
:ruby: https://www.ruby-lang.org/en/
:issue1: https://subtle.de/issues/1
:wow: https://worldofwarcraft.blizzard.com/en-us/
:sublets: https://projects.unexist.dev/projects/subtle/wiki/Writing_sublets
:patchgist: https://gist.github.com/unexist/4ee3cb94c91555b1bac01e23f992b9e4
:pcall: https://www.lua.org/pil/25.2.html

There are many qualities modern software [line-through]#has to# *should* address especially when
done properly.
Among the long list of {ilities}[-ilities], there are some boring and pretty self-explanatory ones
like {maintainability}[maintainability], some dogmatic ones like
{correctness}[correctness]footnote:[Correctness-ily?] and also interesting ones, like
{extensibility}[extensibility].

How a certain quality is best achieved depends on a plethora of things, but overall the targeted
ones should match the requirements and the budget to burn.
Stay put, we don't want to dwell on this longer than this introduction has to be, and we definitely
also don't want to go into detail about essentials ones, this is best done by something with
affinity to lists like {wikipedia}[Wikipedia].
Instead, we fast-forward directly to extensibility and see what this is all about.

According to Wikipedia extensibility revolves around future growth and proper design, but also
mentions scripting languages in the black box and scripting sounds about right for the remainder of
this post.
So please be my guest while I delve a bit in my {FOSS}[FOSS]-history and lay out how different
approaches and why integrating scripting languages is a great idea.

image::go_wrong.png[]

== Barebone

Unbeknownst to my past self, I made my first experience with this kind of extensibility in 2004,
when I started my long journey with {xlib}[Xlib].
During that time I started a project called {deskbar}[deskbar] with the lofty goal to print system
information like cpu load, battery usage etc. directly onto the root window of the X session.
There were plenty of alternatives like {gkrellm}[GKrellM] readily available, but ho likes pre-built
stuff when you can roll your own?

The initial idea was just to include everything in one binary, but I quickly discovered the
ergonomics of re-compiling and shipping everything together are annoying and I switched to a simple
plugin system.

=== Screenshots first

I would have loved to show some screenshots of deskbar in action here, but unfortunately after
messing with {autotools}[Autotools] and trying to compile old {clang}[C]-code with a modern compiler
this is as far as I gotfootnote:[..followed by kilometres of error trace I wasn't in the mood to
fix right now]:

.Build attempt of {deskbar}[deskbar]
[source,shell]
----
$ ./configure && make
deskbar 0.1
-----------------
Build with ZLIB support.......: yes
Build with PNG support........: yes

Plugins:
Common Plugins................: Clock CPU Date
Battery Plugin................: no
XMMS Plugin...................: no // <.>
BMP Plugin....................: no // <.>
Debug Plugin..................: no

The binary will be installed in /usr/local/bin,
the lib in /usr/local/lib and the plugins
in /usr/local/lib/deskbar.

Try make now, good luck!

make  all-recursive
make[1]: Entering directory '/home/unexist/build/deskbar-0.1'
...
/bin/bash ../libtool  --tag=CC   --mode=compile gcc -DHAVE_CONFIG_H -I. -I..     -g -O2  -I/usr/include -I/usr/include -MT htable.lo -MD -MP -MF .deps/htable.Tpo -c -o htable.lo htable.c
libtool: compile:  gcc -DHAVE_CONFIG_H -I. -I.. -g -O2 -I/usr/include -I/usr/include -MT htable.lo -MD -MP -MF .deps/htable.Tpo -c htable.c  -fPIC -DPIC -o .libs/htable.o
In file included from htable.c:2:
/usr/include/string.h:466:13: error: storage class specified for parameter 'explicit_bzero'
  466 | extern void explicit_bzero (void *__s, size_t __n) __THROW __nonnull ((1)) // <.>
      |             ^~~~~~~~~~~~~~
/usr/include/string.h:471:14: error: make[2]: *** [Makefile:457: htable.lo] Error 1
make[2]: Leaving directory '/home/unexist/build/deskbar-0.1/libdeskbar'
make[1]: *** [Makefile:479: all-recursive] Error 1
make[1]: Leaving directory '/home/unexist/build/deskbar-0.1'
make: *** [Makefile:374: all] Error 2storage class specified for parameter 'strsep'
  471 | extern char *strsep (char **__restrict __stringp,
      |              ^~~~~~
/usr/include/string.h:478:14: error: storage class specified for parameter 'strsignal'
  478 | extern char *strsignal (int __sig) __THROW;
      |              ^~~~~~~~~
...
make[2]: *** [Makefile:457: htable.lo] Error 1
make[2]: Leaving directory '/home/unexist/build/deskbar-0.1/libdeskbar'
make[1]: *** [Makefile:479: all-recursive] Error 1
make[1]: Leaving directory '/home/unexist/build/deskbar-0.1'
make: *** [Makefile:374: all] Error 2
----
<.> https://en.wikipedia.org/wiki/XMMS[X Multimedia System (XMMS)]
<.> I can only guess - the plugin is just an empty stub that returns `NULL`
<.> Yes, oh well..

Nevertheless, this output clearly proves there has been a plugin system with conditional
compilation, which bases solely on linking magic.

I digged a bit further and stumbled upon my old project page on {sourceforge}[SourceForge], which
luckily still provides sftp access to the project page:

<{deskbarsf}>

And even more luckily, although the page is a bit empty, the file listing included screenshots:

image::deskbar-05-05-2005.png[]
image::deskbar-shot.png[]

=== Runtime loading

Everything in C is a bit more complicated, so let us ignore the scary memory handling and just
talk about the two interesting calls {dlopen}[dlopen] and {dlsym}[dlsym]:

.{deskbar}[deskbar]/deskbar/plug.c:97
[source,c]
----
DbPlugElement *element = NULL;

element = (DbPlugElement *) malloc (sizeof (DbPlugElement));

snprintf (buf, sizeof (buf), "%s/%s.so", PLUGIN_DIR, file);

element->handle = dlopen (buf, RTLD_LAZY); // <.>

if ((err = dlerror ())) // <.>
    {
        db_log_err ("Cannot load plugin `%s'\n", file);
        db_log_debug ("dlopen (): %s\n", err);

        free (element);

        return;
    }

/* Get entrypoint and call it */
entrypoint      = dlsym (element->handle, "db_plug_init"); // <.>
element->data   = (*entrypoint) (); // <.>
----
<.> Load the named shared object from path
<.> There is apparently a third call, but rarely mentioned at all
<.> Find the address of a named entrypoint
<.> Execute the entrypoint for profit

.Excursion: Linking
****
Linking is complex topic, but in a nutshell during the linking process all intermediate parts
obj(ect)-files and static libraries) are put together and rolled into a final executable binary or
library:

.Linking process based on the diagram from {linker}
[plantuml]
----
rectangle "Static library (1)" as lib1
rectangle "Object file (2)" as obj1
rectangle "Object file" as obj2
rectangle "Linker" as linker
rectangle "Shared object (3)" as so
rectangle "Library (4)" as lib3
rectangle "Binary (4)" as bin

lib1 --> linker
obj1 --> linker
obj2 --> linker

linker --> lib3
linker --> so
linker --> bin
----
<1> Static libraries are directly included in the resulting artifact
<2> Object files are the compiled form of the source code
<4> {sharedobj}[Shared objects] can be loaded at runtime
<3> The result can either be a shared, library or executable type
****

The entrypoint here is quite interesting, since the main application cannot know what is included
in the plugin or even what is exported.
Following the idea of {convention}[Convention-over-configuration], the defined contract here
expects a symbol named `db_plug_init` inside a plugin, which is called on load and *must* return
a pointer to an initialized struct of type `DBPlug`:

.{deskbar}[deskbar]/plugins/battery.c:107
[source,c]
----
static DbPlug plugin =
{
    "Battery",       /* Plugin name */
    battery_create,  /* Plugin create function */
    battery_update,  /* Plugin update function */
    battery_destroy, /* Plugin destroy function */

    &data,           /* Plugin data */
    NULL,            /* Plugin format */

    3600             /* Plugin update interval */
};

DbPlug *
db_plug_init (void)
{
    plug = &plugin;

    return (&plugin); // <.>
}
----
<.> Pass the local address back to the main application

Once loaded the plugin is called in the given interval and can exchange data with the main
application.

.{deskbar}[deskbar]/plugins/battery.c:58
[source,c]
----
void
battery_update (void)
{
    int capacity    = 0,
    percent         = 0;

    char buf[100], state[20];

    /* Get battery info */
    if (!fd1)
        {
            snprintf (buf, sizeof (buf), "/proc/acpi/battery/BAT%d/state", bat_slot); // <.>

            fd1 = fopen (buf, "r");

            memset (buf, 0, sizeof (buf));
        }
    else
        fseek (fd1, 0, SEEK_SET);
...
}
----
<.> Here the battery plugin checks the battery values from the {acpi}[ACPI] interface

Allowing contribution this way is really easy and powerful, but like so often comes with a catch.
{segfault}[Segmentation faults], the bane of software
engineering, don't make halt inside plugins like they should, but they wipe the board and kill the
entire application.

I think {torvalds}[Torvalds] nailed it perfectly and I agree this should never happen:

[quote,Linus Torvals,https://www.shutupmauro.com/]
[line-through]#Mauro, SHUT THE FUCK UP!# +
WE DO NOT BREAK USERSPACE!

I am kind of surprised how far I went in trying to keep problems in the plugin at bay.
The original project included memory managementfootnote:[Check `mem.c` if you are curious] for
plugins and also applied the next two calls I'd like to demonstrate next.

=== Error handling

Handling segmentation faults properly is really difficult and the common sense is normally catch
them and exit gracefully when possible.
Still, there are cases when faults _can_ be safely ignored and a plugin interface is a paragon for
this.

This can be done with the pair of {setjmp}[setjmp] and {longjmp}[longjmp], which behave for most
practical senses like a {goto}[goto] on steroids:

.{deskbar}[deskbar]/deskbar/plug.c:25
[source,c]
----
static int¬                                                                                                                                                                                                                                                                                                                                                              26 save_call (DbPlugElement *element,¬
save_call (DbPlugElement *element,
    DbPlugFunc plugfunc
    const char *name)
{
    if (plugfunc)
        {
            if (setjmp (env) == 0) // <.>
                plugfunc ();
            else
                {
                    db_log_mesg ("Ayyyee! Segmentation fault in plugin %s!\n", element->data->name); // <.>
                    db_log_debug ("Call to %s () failed\n", name);
                    db_plug_unload (element);

                    return (1);
                }
        }

    return (0);
}
----
<.> Save stack and instruction pointer for later use when it is for the first time; otherwise ditch
the plugin
<.> Well, different times back then..

When the application receives the bad {signal}[signal] `SISEGV`, it checks if there are stored stack
and instruction values and rewinds the stack accordingly:

.{deskbar}[deskbar]/deskbar/sig.c:35
[source,c]
----
static void
sig_handler (int sig)
{
    switch (sig)
        {
            case SIGSEGV:
                longjmp (env, 1); // <.>

                db_log_debug ("Something went wrong! Segmentation fault!\n");
                db_sig_destroy ();

                abort ();
            break;
...
}
----
<.>  Check the values and pass control if necessary; otherwise just bail out

=== Recap

|===
| Ease of use | Richness of API | Language agnostic | Error handling

| Low; requires compilation and linking
| The API is simple, but can be enriched by the host
| No; requires plugins to be in Cfootnote:[Technically everything that can be linked, so other
languages _might_ actually be possible here. Dare I to try {rust}[Rust]?]
| Arcane; requires stack unwinding
|===

== Scripting languages

Three years later in 2007 I continued on building upon my Xlib skills and started my long-lasting
project {subtle}[subtle].

Over the years there have been many major breaking changes, from the initial design to the state
it currently is in.
Two of the post-related changes were the integration of the scripting language {lua}[Lua] and its
later replacement with{Ruby}[Ruby] after a few years in this glorious {issue1}[issue #1].

=== Integrating Lua

I am not entire sure where I picked Lua up, but I never played {wow}[WoW] so probably from somewhere
else and I can only talk about the state and API from back then.

Adding a scripting language solves quite a few problems:

- File loading and parsing can be offloaded to the language core
- The language itself comes with a basic subset of things you can do with it
- Config handling can also be directly offloaded

Starting with the easy part, offloading the config handling was one of the first things I did and
this made a config like this entirely possible:

.{subtle}[subtle-0.7b]/config/config.lua:1
[source,lua]
----
-- Options config
font = {
    face    = "lucidatypewriter",  -- Font face for the text
    style   = "medium",            -- Font style (medium|bold|italic)
    size    = 12                   -- Font size
}

-- Color config
colors = {
    font       = "#ffffff",        -- Color of the font
    border     = "#ffffff",        -- Color of the border/tiles
    normal     = "#CFDCE6",        -- Color of the inactive windows
    focus      = "#6096BF",        -- Color of the focussed window
    shade      = "#bac5ce",        -- Color of shaded windows
    background = "#596F80"         -- Color of the root background
}
...
----

The battery plugin from before, meanwhile rebranded to {sublets}[sublets], lost a bit of its
arcaneness and became quite readable:

.{subtle}[subtle-0.7b]/sublets/battery.lua:30
[source,lua]
----
-- Get remaining battery in percent
function battery:meter()
    local f = io.open("/proc/acpi/battery/BAT" .. battery.slot .. "/state", "r")
    local info = f:read("*a")
    f:close()

    _, _, battery.remaining = string.find(info, "remaining capacity:%s*(%d+).*")
    _, _, battery.rate      = string.find(info, "present rate:%s*(%d+).*")
    _, _, battery.state                     = string.find(info, "charging state:%s*(%a+).*")

    return(math.floor(battery.remaining * 100 / battery.capacity))
end
----

==== Time for Screenshots

Trying my luck to actual attempt to compile it to provide a screenshot this time ended quickly as
well:

.Build attempt of {subtle}[subtle-0.7b]
[source,shell]
----
$ ./configure && make
...
subtle 0.7b
-----------------
Binary....................: /usr/local/bin
Sublets...................: /usr/local/share/subtle
Config....................: /usr/local/etc/subtle

Debugging messages........:

Try make now, good luck!

make  all-recursive
make[1]: Entering directory '/home/unexist/build/subtle-0.7b'
Making all in src
...
if gcc -DHAVE_CONFIG_H -I. -I. -I.. -I..   -g -O2  -I/usr/include/lua5.1  -g -O2  -MT subtle-event.o -MD -MP -MF ".deps/subtle-event.Tpo" -c -o subtle-event.o `test -f 'event.c' || echo './'`event.c; \
then mv -f ".deps/subtle-event.Tpo" ".deps/subtle-event.Po"; else rm -f ".deps/subtle-event.Tpo"; exit 1; fi
event.c: In function ‘subEventLoop’:
event.c:352:57: error: implicit declaration of function ‘subSubletSift’; did you mean ‘subSubletKill’? [-Wimplicit-function-declaration]
  352 |                                                         subSubletSift(1);
      |                                                         ^~~~~~~~~~~~~
      |                                                         subSubletKill
make[2]: *** [Makefile:310: subtle-event.o] Error 1
make[2]: Leaving directory '/home/unexist/build/subtle-0.7b/src'
make[1]: *** [Makefile:233: all-recursive] Error 1
make[1]: Leaving directory '/home/unexist/build/subtle-0.7b'
make: *** [Makefile:171: all] Error 2
----

This is kind of embarrassing for an official release and really have to question the quality in
retrospect, but this won't stop us now.

image::few_hours_later.png[]

After a dive into the code there were some obviously problems and also a blatant oversight, but you
can find the patch here if you are interested:

<{patchgist}>

And without further ado here is finally the screenshot of the scripting part in action before we
check how this is actual done under the hood:

image::subtle-0.7b.png[]

=== Runtime loading

Essentially Lua is a stackmachine and the interaction with the core API used to be
footnote:[Haven't touched Lua for ages] exactly like the one I wrote back then during my studies.

I've removed a bit of the fluff and checks upfront, so we can have a quick glance at the config
loading and jump further into nitty details:

.{subtle}[subtle-0.7b]/src/lua.c:150
[source,c]
----
subLogDebug("Reading `%s'\n", buf);
if(luaL_loadfile(configstate, buf) || lua_pcall(configstate, 0, 0, 0)) // <.>
    {
        subLogDebug("%s\n", (char *)lua_tostring(configstate, -1));
        lua_close(configstate);
        subLogError("Can't load config file `%s'.\n", buf);
    }

/* Parse and load the font */¬
face  = GetString(configstate, "font", "face", "fixed"); // <.>
style = GetString(configstate, "font", "style", "medium");
size  = GetNum(configstate, "font", "size", 12);
----
<.> Internal calls to load the config file and just execute it in a safe way {pcall}[pcall]
<.> Once everything is stored inside `configstate` we fetch required values

.{subtle}[subtle-0.7b]/src/lua.c:47+72
[source,c]
----
#define GET_GLOBAL(configstate) do { \ // <.>
    lua_getglobal(configstate, table); \ // <.>
    if(lua_istable(configstate, -1)) \
        { \
            lua_pushstring(configstate, field); \ // <.>
            lua_gettable(configstate, -2); \
        } \
} while(0)

static char *
GetString(lua_State *configstate,
    const char *table,
    const char *field,
    char *fallback)
{
    GET_GLOBAL(configstate);
    if(!lua_isstring(configstate, -1)) // <.>
        {
            subLogDebug("Expected string, got `%s' for `%s'.\n", lua_typename(configstate, -1), field);
            return(fallback);
        }
    return((char *)lua_tostring(configstate, -1)); // <.>
}
----
<.> Blocks in C macros require this fancy hack; probably best to skip over it
<.> We check and fetch a tablefootnote:[There are jokes about every type in Lua is a table]
<.> Push the string onto the current stack
<.> And pull the value with index -2 from the stack

.Excursion: Stackmachine
****
Linking is complex topic, but in a nutshell during the linking process all intermediate parts
obj(ect)-files and static libraries) are put together and rolled into a final executable binary or
library:

.Stack handling diagram
[plantuml]
----
skinparam linetype ortho
skinparam nodesep 20
skinparam ranksep 20

rectangle "lua_getglobal (1)" as l1
rectangle "lua_pushstring (2)" as l2
rectangle "lua_gettable (3)" as l3
rectangle "lua_gettable (4)" as l4
rectangle "lucidatypewriter" as res

stack "Stack" as s1 {
}

stack "Stack" as s2 {
  rectangle "[0] font"
}

stack "Stack" as s3 {
  rectangle "[0]: font" as s3_font
  rectangle "[-1] face"  as s3_face
}

stack "Stack" as s4 {
  rectangle "[0] font" as s4_font
  rectangle "[-1] face" as s4_face
  rectangle "[-2] lucidatypewriter" as s4_luci
}

s3_font -[hidden]d-> s3_face
s4_font -[hidden]d-> s4_face
s4_face -[hidden]d-> s4_luci

s1 -[hidden]r-> s2
s2 -[hidden]r-> s3
s3 -[hidden]r-> s4

s1 -[hidden]u-> l1
s2 -[hidden]u-> l2
s3 -[hidden]u-> l3
s4 -[hidden]u-> l4

l1 -r-> l2
l2 -r-> l3
l3 -r-> l4
l4 -r-> res
----
<1> Static libraries are directly included in the resulting artifact
<2> Object files are the compiled form of the source code
<4> {sharedobj}[Shared objects] can be loaded at runtime
<3> The result can either be a shared, library or executable type
****

=== Integrating Ruby

==== Time for Screenshots

==== Runtime loading

==== Error handling

=== Integrating JavaScript

==== Time for Screenshots

==== Runtime loading

==== Error handling

=== Recap

|===
| Ease of use | Richness of API | Language agnostic | Error handling
|===

== Webassembly

=== Screenshots first

=== Runtime loading

==== Error handling

=== Recap

|===
| Ease of use | Richness of API | Language agnostic | Error handling
|===

== Conclusion

The list of examples is quite long, but please help yourself:

- <{deskbar}>
- <{subtle}>
- <{subtle-rs}>
- <{touchjs}>
- <{rubtle}>

[bibliography]
== Bibliography
