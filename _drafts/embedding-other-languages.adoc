---
layout: post
title: Extensibility through scripting languages
description: TBD
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: showcase c rust lua ruby javascript duktape extism
categories: tech
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/extensibility_through_scripting_languages
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/extensibility_through_scripting_languages
endif::[]
:figure-caption!:
:table-caption!:
:page-liquid:
:source-highlighter: highlight.js

:subtle-rs: https://github.com/unexist/subtle-rs
:touchjs: https://github.com/unexist/touchjs
:rubtle: https://github.com/unexist/rubtle
:extism: https://extism.org/
:wasm: https://webassembly.org/

:ilities: https://en.wikipedia.org/wiki/List_of_system_quality_attributes
:maintainability: https://en.wikipedia.org/wiki/Maintainability
:correctness: https://en.wikipedia.org/wiki/Correctness_(computer_science)
:extensibility: https://en.wikipedia.org/wiki/Extensibility
:wikipedia: https://en.wikipedia.org
:foss: https://en.wikipedia.org/wiki/Free_and_open-source_software
:xlib: https://en.wikipedia.org/wiki/Correctness_(computer_science)
:deskbar: https://sourceforge.net/projects/deskbar/
:gkrellm: https://gkrellm.srcbox.net/
:clang: https://en.wikipedia.org/wiki/C_(programming_language)
:sourceforge: https://sourceforge.net/
:deskbarsf: https://deskbar.sourceforge.net
:autotools: https://en.wikipedia.org/wiki/GNU_Autotools
:linker: https://en.wikipedia.org/wiki/Linker_(computing)
:sharedobj: https://en.wikipedia.org/wiki/Shared_library
:dlopen: https://man7.org/linux/man-pages/man3/dlopen.3.html
:dlsym: https://man7.org/linux/man-pages/man3/dlsym.3.html
:convention: https://en.wikipedia.org/wiki/Convention_over_configuration
:acpi: https://en.wikipedia.org/wiki/ACPI
:segfault: https://en.wikipedia.org/wiki/Segmentation_fault
:torvalds: https://en.wikipedia.org/wiki/Linus_Torvalds
:rust: https://rust-lang.org/
:setjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:longjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:goto: https://learn.microsoft.com/en-us/cpp/c-language/goto-and-labeled-statements-c
:signal: https://man7.org/linux/man-pages/man7/signal.7.html
:subtle: https://github.com/unexist/subtle
:lua: https://www.lua.org/
:ruby: https://www.ruby-lang.org/en/
:issue1: https://subtle.de/issues/1
:wow: https://worldofwarcraft.blizzard.com/en-us/
:sublets: https://projects.unexist.dev/projects/subtle/wiki/Writing_sublets
:patchgist: https://gist.github.com/unexist/4ee3cb94c91555b1bac01e23f992b9e4
:luapcall: https://www.lua.org/pil/25.2.html
:luagetglobal: https://www.lua.org/manual/2.4/node16.html
:luagettable: https://www.lua.org/pil/25.1.html
:luapushstring: https://www.lua.org/pil/24.2.1.html
:luatostring: https://www.lua.org/pil/24.2.2.html
:luapcall: https://www.lua.org/pil/25.2.html

There are many qualities modern software [line-through]#has to# *should* address especially when
done properly.
Among the long list of {ilities}[-ilities], there are some boring and pretty self-explanatory ones
like {maintainability}[maintainability], some dogmatic ones like
{correctness}[correctness]footnote:[Correctness-ily?] and also interesting ones, like
{extensibility}[extensibility].

How a certain quality is best achieved depends on a plethora of things, but overall the targeted
ones should match the requirements and the budget to burn.
Stay put, we don't want to dwell on this longer than this introduction has to be, and we definitely
also don't want to go into detail about essentials ones, this is best done by something with
affinity to lists like {wikipedia}[Wikipedia].
Instead, we fast-forward directly to extensibility and see what this is all about.

According to Wikipedia extensibility revolves around future growth and proper design, but also
mentions scripting languages in the black box and scripting sounds about right for the remainder of
this post.
So please be my guest while I delve a bit in my {FOSS}[FOSS]-history and lay out how different
approaches and why integrating scripting languages is a great idea.

image::go_wrong.png[]

== Barebone

Unbeknownst to my past self, I made my first experience with this kind of extensibility in 2004,
when I started my long journey with {xlib}[Xlib].
During that time I started a project called {deskbar}[deskbar] with the lofty goal to print system
information like cpu load, battery usage etc. directly onto the root window of the X session.
There were plenty of alternatives like {gkrellm}[GKrellM] readily available, but ho likes pre-built
stuff when you can roll your own?

The initial idea was just to include everything in one binary, but I quickly discovered the
ergonomics of re-compiling and shipping everything together are annoying and I switched to a simple
plugin system.

=== Screenshots first

I would have loved to show some screenshots of deskbar in action here, but unfortunately after
messing with {autotools}[Autotools] and trying to compile old {clang}[C]-code with a modern compiler
this is as far as I gotfootnote:[..followed by kilometres of error trace I wasn't in the mood to
fix right now]:

.Build attempt of {deskbar}[deskbar]
[source,shell]
----
$ ./configure && make
deskbar 0.1
-----------------
Build with ZLIB support.......: yes
Build with PNG support........: yes

Plugins:
Common Plugins................: Clock CPU Date
Battery Plugin................: no
XMMS Plugin...................: no // <.>
BMP Plugin....................: no // <.>
Debug Plugin..................: no

The binary will be installed in /usr/local/bin,
the lib in /usr/local/lib and the plugins
in /usr/local/lib/deskbar.

Try make now, good luck!

make  all-recursive
make[1]: Entering directory '/home/unexist/build/deskbar-0.1'
...
/bin/bash ../libtool  --tag=CC   --mode=compile gcc -DHAVE_CONFIG_H -I. -I..     -g -O2  -I/usr/include -I/usr/include -MT htable.lo -MD -MP -MF .deps/htable.Tpo -c -o htable.lo htable.c
libtool: compile:  gcc -DHAVE_CONFIG_H -I. -I.. -g -O2 -I/usr/include -I/usr/include -MT htable.lo -MD -MP -MF .deps/htable.Tpo -c htable.c  -fPIC -DPIC -o .libs/htable.o
In file included from htable.c:2:
/usr/include/string.h:466:13: error: storage class specified for parameter 'explicit_bzero'
  466 | extern void explicit_bzero (void *__s, size_t __n) __THROW __nonnull ((1)) // <.>
      |             ^~~~~~~~~~~~~~
/usr/include/string.h:471:14: error: make[2]: *** [Makefile:457: htable.lo] Error 1
make[2]: Leaving directory '/home/unexist/build/deskbar-0.1/libdeskbar'
make[1]: *** [Makefile:479: all-recursive] Error 1
make[1]: Leaving directory '/home/unexist/build/deskbar-0.1'
make: *** [Makefile:374: all] Error 2storage class specified for parameter 'strsep'
  471 | extern char *strsep (char **__restrict __stringp,
      |              ^~~~~~
/usr/include/string.h:478:14: error: storage class specified for parameter 'strsignal'
  478 | extern char *strsignal (int __sig) __THROW;
      |              ^~~~~~~~~
...
make[2]: *** [Makefile:457: htable.lo] Error 1
make[2]: Leaving directory '/home/unexist/build/deskbar-0.1/libdeskbar'
make[1]: *** [Makefile:479: all-recursive] Error 1
make[1]: Leaving directory '/home/unexist/build/deskbar-0.1'
make: *** [Makefile:374: all] Error 2
----
<.> https://en.wikipedia.org/wiki/XMMS[X Multimedia System (XMMS)]
<.> I can only guess - the plugin is just an empty stub that returns `NULL`
<.> Yes, oh well..

Nevertheless, this output clearly proves there has been a plugin system with conditional
compilation, which bases solely on linking magic, and we have to move on.

.Edit
****
I dug a bit further and stumbled upon my old project page on {sourceforge}[SourceForge], which
luckily still provides sftp access to the project page:

<{deskbarsf}>

And with even more luck, although the page is a bit empty, the file listing included screenshots:

image::deskbar-05-05-2005.png[]
image::deskbar-shot.png[]
****

=== Runtime loading

Everything in C is a bit more complicated, so let us ignore the scary memory handling and just
talk about the two interesting calls {dlopen}[dlopen] and {dlsym}[dlsym]:

.{deskbar}[deskbar]/deskbar/plug.c:97
[source,c]
----
DbPlugElement *element = NULL;

element = (DbPlugElement *) malloc (sizeof (DbPlugElement));

snprintf (buf, sizeof (buf), "%s/%s.so", PLUGIN_DIR, file);

element->handle = dlopen (buf, RTLD_LAZY); // <.>

if ((err = dlerror ())) // <.>
    {
        db_log_err ("Cannot load plugin `%s'\n", file);
        db_log_debug ("dlopen (): %s\n", err);

        free (element);

        return;
    }

/* Get entrypoint and call it */
entrypoint      = dlsym (element->handle, "db_plug_init"); // <.>
element->data   = (*entrypoint) (); // <.>
----
<.> Load the named shared object from path
<.> There is apparently a third call, but rarely mentioned at all
<.> Find the address of a named entrypoint
<.> Execute the entrypoint for profit

.Excursion: Linking in a Nutshell
****
Linking is complex topic, but in a nutshell during the linking process all intermediate parts
obj(ect)-files and static libraries) are put together and rolled into a final executable binary or
library:

.Linking process based on the diagram from {linker}
[plantuml]
----
'!theme unexist from {{ site.asciidoctor_attributes.plantumldir }}

skinparam linetype ortho
skinparam nodesep 20
skinparam ranksep 20

rectangle "Static library (1)" as lib1
rectangle "Object file (2)" as obj1
rectangle "Object file" as obj2
rectangle "Linker" as linker
rectangle "Shared object (3)" as so
rectangle "Library (4)" as lib3
rectangle "Binary (4)" as bin

lib1 --> linker
obj1 --> linker
obj2 --> linker

linker --> lib3
linker --> so
linker --> bin
----
<1> Static libraries are directly included in the resulting artifact
<2> Object files are the compiled form of the source code
<4> {sharedobj}[Shared objects] can be loaded at runtime
<3> The result can either be a shared, library or executable type
****

The entrypoint here is quite interesting, since the main application cannot know what is included
in the plugin or even what is exported.
Following the idea of {convention}[Convention-over-configuration], the defined contract here
expects a symbol named `db_plug_init` inside a plugin, which is called on load and *must* return
a pointer to an initialized struct of type `DBPlug`:

.{deskbar}[deskbar]/plugins/battery.c:107
[source,c]
----
static DbPlug plugin =
{
    "Battery",       /* Plugin name */
    battery_create,  /* Plugin create function */
    battery_update,  /* Plugin update function */
    battery_destroy, /* Plugin destroy function */

    &data,           /* Plugin data */
    NULL,            /* Plugin format */

    3600             /* Plugin update interval */
};

DbPlug *
db_plug_init (void)
{
    plug = &plugin;

    return (&plugin); // <.>
}
----
<.> Pass the local address back to the main application

Once loaded the plugin is called in the given interval and can exchange data with the main
application.

.{deskbar}[deskbar]/plugins/battery.c:58
[source,c]
----
void
battery_update (void)
{
    int capacity    = 0,
    percent         = 0;

    char buf[100], state[20];

    /* Get battery info */
    if (!fd1)
        {
            snprintf (buf, sizeof (buf), "/proc/acpi/battery/BAT%d/state", bat_slot); // <.>

            fd1 = fopen (buf, "r");

            memset (buf, 0, sizeof (buf));
        }
    else
        fseek (fd1, 0, SEEK_SET);
...
}
----
<.> Here the battery plugin checks the battery values from the {acpi}[ACPI] interface

Allowing contribution this way is really easy and powerful, but like so often comes with a catch.
{segfault}[Segmentation faults], the bane of software
engineering, don't make halt inside plugins like they should, but they wipe the board and kill the
entire application.

I think {torvalds}[Torvalds] nailed it perfectly and I agree this should never happen:

[quote,Linus Torvals,https://www.shutupmauro.com/]
[line-through]#Mauro, SHUT THE FUCK UP!# +
WE DO NOT BREAK USERSPACE!

I am kind of surprised how far I went in trying to keep problems in the plugin at bay.
The original project included memory managementfootnote:[Check `mem.c` if you are curious] for
plugins and also applied the next two calls I'd like to demonstrate next.

=== Error handling

Handling segmentation faults properly is really difficult and the common sense is normally catch
them and exit gracefully when possible.
Still, there are cases when faults _can_ be safely ignored and a plugin interface is a paragon for
this.

This can be done with the pair of {setjmp}[setjmp] and {longjmp}[longjmp], which behave for most
practical senses like a {goto}[goto] on steroids:

.{deskbar}[deskbar]/deskbar/plug.c:25
[source,c]
----
static int¬                                                                                                                                                                                                                                                                                                                                                              26 save_call (DbPlugElement *element,¬
save_call (DbPlugElement *element,
    DbPlugFunc plugfunc
    const char *name)
{
    if (plugfunc)
        {
            if (setjmp (env) == 0) // <.>
                plugfunc ();
            else
                {
                    db_log_mesg ("Ayyyee! Segmentation fault in plugin %s!\n", element->data->name); // <.>
                    db_log_debug ("Call to %s () failed\n", name);
                    db_plug_unload (element);

                    return (1);
                }
        }

    return (0);
}
----
<.> Save stack and instruction pointer for later use when it is for the first time; otherwise ditch
the plugin
<.> Well, different times back then..

When the application receives the bad {signal}[signal] `SISEGV`, it checks if there are stored stack
and instruction values and rewinds the stack accordingly:

.{deskbar}[deskbar]/deskbar/sig.c:35
[source,c]
----
static void
sig_handler (int sig)
{
    switch (sig)
        {
            case SIGSEGV:
                longjmp (env, 1); // <.>

                db_log_debug ("Something went wrong! Segmentation fault!\n");
                db_sig_destroy ();

                abort ();
            break;
...
}
----
<.>  Check the values and pass control if necessary; otherwise just bail out

=== Recap

|===
| Ease of use | Richness of API | Language agnostic | Error handling

| Low; requires compilation and linking
| The API is simple, but can be enriched by the host
| No; requires plugins to be in Cfootnote:[Technically everything that can be linked, so other
languages _might_ actually be possible here. Dare I to try {rust}[Rust]?]
| Arcane; requires stack unwinding
|===

== Scripting languages

Three years later in 2007 I continued on building upon my Xlib skills and started my long-lasting
project {subtle}[subtle].

Over the years there have been many major breaking changes, from the initial design to the state
it currently is in.
Two of the post-related changes were the integration of the scripting language {lua}[Lua] and its
later replacement with{Ruby}[Ruby] after a few years in this glorious {issue1}[issue #1].

=== Integrating Lua

I am not entire sure where I picked Lua up, but I never played {wow}[WoW] so probably from somewhere
else and I can only talk about the state and API from back then.

Adding a scripting language solves quite a few problems:

- File loading and parsing can be offloaded to the language core
- The language itself comes with a basic subset of things you can do with it
- Bonus: Config handling can also be directly offloaded

==== Time for Screenshots

My attempt of trying to compile the project and provide an actual screenshot this time ended
quickly as well:

.Build attempt of {subtle}[subtle-0.7b]
[source,shell]
----
$ ./configure && make
...
subtle 0.7b
-----------------
Binary....................: /usr/local/bin
Sublets...................: /usr/local/share/subtle
Config....................: /usr/local/etc/subtle

Debugging messages........:

Try make now, good luck!

make  all-recursive
make[1]: Entering directory '/home/unexist/build/subtle-0.7b'
Making all in src
...
if gcc -DHAVE_CONFIG_H -I. -I. -I.. -I..   -g -O2  -I/usr/include/lua5.1  -g -O2  -MT subtle-event.o -MD -MP -MF ".deps/subtle-event.Tpo" -c -o subtle-event.o `test -f 'event.c' || echo './'`event.c; \
then mv -f ".deps/subtle-event.Tpo" ".deps/subtle-event.Po"; else rm -f ".deps/subtle-event.Tpo"; exit 1; fi
event.c: In function ‘subEventLoop’:
event.c:352:57: error: implicit declaration of function ‘subSubletSift’; did you mean ‘subSubletKill’? [-Wimplicit-function-declaration]
  352 |                                                         subSubletSift(1);
      |                                                         ^~~~~~~~~~~~~
      |                                                         subSubletKill
make[2]: *** [Makefile:310: subtle-event.o] Error 1
make[2]: Leaving directory '/home/unexist/build/subtle-0.7b/src'
make[1]: *** [Makefile:233: all-recursive] Error 1
make[1]: Leaving directory '/home/unexist/build/subtle-0.7b'
make: *** [Makefile:171: all] Error 2
----

This is kind of embarrassing for an official release and really have to question the quality in
retrospect, but this won't stop us now.

image::few_hours_later.png[]

After a dive into the code there were some obviously problems and also a blatant oversight, but you
can find the patch here if you are interested:

<{patchgist}>

And without further ado here is finally the screenshot of the scripting part in action, before we
dive into how this is actually done under the hood:

image::subtle-0.7b.png[]

==== Runtime loading

Starting with the easy part, offloading the config handling was one of the first things I did and
this made a config like this entirely possible:

.{subtle}[subtle-0.7b]/config/config.lua:1
[source,lua]
----
-- Options config
font = {
    face    = "lucidatypewriter",  -- Font face for the text
    style   = "medium",            -- Font style (medium|bold|italic)
    size    = 12                   -- Font size
}

-- Color config
colors = {
    font       = "#ffffff",        -- Color of the font
    border     = "#ffffff",        -- Color of the border/tiles
    normal     = "#CFDCE6",        -- Color of the inactive windows
    focus      = "#6096BF",        -- Color of the focussed window
    shade      = "#bac5ce",        -- Color of shaded windows
    background = "#596F80"         -- Color of the root background
}
...
----

Essentially the C API of Lua is a stack machine and the interaction with is through pushing and
popping values onto and from the
stack.footnote:[Haven't touched Lua for ages, but apparently this is still true.]

I've removed a bit of the fluff and checks upfront, so we can have a quick glance at the config
loading and jump further into nitty-gritty details:

.{subtle}[subtle-0.7b]/src/lua.c:150
[source,c]
----
subLogDebug("Reading `%s'\n", buf);
if(luaL_loadfile(configstate, buf) || lua_pcall(configstate, 0, 0, 0)) // <.>
    {
        subLogDebug("%s\n", (char *)lua_tostring(configstate, -1));
        lua_close(configstate);
        subLogError("Can't load config file `%s'.\n", buf);
    }

/* Parse and load the font */¬
face  = GetString(configstate, "font", "face", "fixed"); // <.>
style = GetString(configstate, "font", "style", "medium");
size  = GetNum(configstate, "font", "size", 12);
----
<.> Internal calls to load the config file and just execute it in a safe way {luapcall}[pcall]
<.> Once everything is stored inside `configstate` we fetch required values

.{subtle}[subtle-0.7b]/src/lua.c:47+72
[source,c]
----
#define GET_GLOBAL(configstate) do { \ // <.>
    lua_getglobal(configstate, table); \ // <.>
    if(lua_istable(configstate, -1)) \
        { \
            lua_pushstring(configstate, field); \ // <.>
            lua_gettable(configstate, -2); \
        } \
} while(0)

static char *
GetString(lua_State *configstate,
    const char *table,
    const char *field,
    char *fallback)
{
    GET_GLOBAL(configstate);
    if(!lua_isstring(configstate, -1)) // <.>
        {
            subLogDebug("Expected string, got `%s' for `%s'.\n", lua_typename(configstate, -1), field);
            return(fallback);
        }
    return((char *)lua_tostring(configstate, -1)); // <.>
}
----
<.> Blocks in C macros require this fancy hack; probably best to skip over it
<.> We check and fetch a tablefootnote:[There are jokes about how every type in Lua is a table..]
<.> Push the string onto the current stack
<.> Pull the value with index -2 from the stack
<.> And convert it to our desired format

.Excursion: Playing with the stack
****
If you haven't played with stack machines before it might be a bit difficult to follow what it is
done, so here is a small break down how the API works:

.Stack handling diagram
[plantuml]
----
'!theme unexist from {{ site.asciidoctor_attributes.plantumldir }}

skinparam linetype ortho
skinparam nodesep 20
skinparam ranksep 20

together {
    rectangle "lua_getglobal (1)" as l1
    stack "Stack (1)" as s1
}

together {
    rectangle "lua_pushstring (2)" as l2
    stack "Stack (2)" as s2 {
        rectangle "[-1] font\n(Table)"
    }
}

together {
    rectangle "lua_gettable (3)" as l3
    stack "Stack (3)" as s3 {
        rectangle "[-1] font\n(Table)" as s3_font
        rectangle "[-2] face\n(String)"  as s3_face
    }
}

together {
    rectangle "lua_tostring (4)" as l4
    stack "Stack (4)" as s4 {
        rectangle "[-1] lucidatypewriter\n(String)" as s4_luci
    }
}

legend right
    | (1) | Step # |
    | [-1] | Stack position |
    | (String) | Data type |
endlegend

' Placement
s3_font -[hidden]d-> s3_face

s1 -[hidden]r-> s2
s2 -[hidden]r-> s3
s3 -[hidden]r-> s4

l1 -[hidden]d-> s1
l2 -[hidden]d-> s2
l3 -[hidden]d-> s3
l4 -[hidden]d-> s4

' Arrows
l1 -r--> l2
l2 -r--> l3
l3 -r--> l4
----
<1> Call {luagetglobal}[lua_getglobal] to put the table `font` onto the stack at position
`-1` footnote:[Lua uses negative numbers ]
<2> Call {luapushstring}[lua_pushstring] to put the string `face` of the desired row name on the
stack at position `-1`
<3> Call {luagettable}[lua_gettable] to consume both values and fetch the row by given name from
the table and put the result at stack position `-1`
<4> Call {luatostring}[lua_tostring] to convert on the stack at position `-1` to string if possible
****

==== Error handling

Loading of plugins at runtime is basically the same as loading the config upfront, so let us just
move on to error handling, which is slightly more interesting.
It is probably no surprise, but the API is quite rudimentary and the handling of the stack and
calls in case of an actual error is up to person to embed the engine.

Before we can see how this is done, let us quickly check how our battery plugin evolved from the
arcane version in C to the Lua glory.
First of all, plugins have been rebranded to {sublets}[sublets]footnote:[You probably get the pun..]
and it (at least to me) became a bit more readable:

.{subtle}[subtle-0.7b]/sublets/battery.lua:30
[source,lua]
----
-- Get remaining battery in percent
function battery:meter() // <.>
    local f = io.open("/proc/acpi/battery/BAT" .. battery.slot .. "/state", "r")
    local info = f:read("*a")
    f:close()

    _, _, battery.remaining = string.find(info, "remaining capacity:%s*(%d+).*")
    _, _, battery.rate      = string.find(info, "present rate:%s*(%d+).*")
    _, _, battery.state     = string.find(info, "charging state:%s*(%a+).*")

    return(math.floor(battery.remaining * 100 / battery.capacity))
end
----
<.> The `:` here is used as a kind of namespace separator this is handled as a global table
called `battery` with the entry `meter`.

Once the sublet is loaded and initialized we can just call it analogue to our `save_call` from
before:

.{subtle}[subtle-0.7b]/src/lua.c:345
[source,c]
----
void
subLuaCall(SubSublet *s)
{
    if(s)
        {
            lua_settop(state, 0); // <.>
            lua_rawgeti(state, LUA_REGISTRYINDEX, s->ref);
            if(lua_pcall(state, 0, 1, 0)) // <.>
                {
                    if(s->flags & SUB_SUBLET_FAIL_THIRD) // <.>
                        {
                            subLogWarn("Unloaded sublet (#%d) after 3 failed attempts\n", s->ref);
                            subSubletDelete(s);
                            return;¬
                        }
                    else if(s->flags & SUB_SUBLET_FAIL_SECOND) s->flags |= SUB_SUBLET_FAIL_THIRD;
                    else if(s->flags & SUB_SUBLET_FAIL_FIRST) s->flags |= SUB_SUBLET_FAIL_SECOND;

                    subLogWarn("Failed attempt #%d to call sublet (#%d).\n",
                        s->flags & SUB_SUBLET_FAIL_SECOND) ? 2 : 1, s->ref);
                }

            switch(lua_type(state, -1)) // <.>
                {
                    case LUA_TNIL: subLogWarn("Sublet (#%d) does not return any usuable value\n", s->ref);>break;¬                                                                                                                                                     370 >--->--->--->--->---case LUA_TNUMBER: s->number = (int)lua_tonumber(state, -1); break;
                    case LUA_TSTRING:
                        if(s->string) free(s->string);
                        s->string = strdup((char *)lua_tostring(state, -1));
                        break;
                    default:
                        subLogDebug("Sublet (#%d) returned unkown type %s\n", s->ref, lua_typename(state, -1));
                        lua_pop(state, -1);
                    }
                }
        }
}
----
<.> A bit stack setup upfront
<.> Here we call {luapcall}[lua_pcall], which abstracts the nasty `setjmp` and `longjmp` handling
for us away
<.> Looks like I discovered bitflags there and utilized it for error handling
<.> Type handling for a more generic interface

=== Integrating Ruby

==== Time for Screenshots

==== Runtime loading

==== Error handling

=== Integrating JavaScript

==== Time for Screenshots

==== Runtime loading

==== Error handling

=== Recap

|===
| Ease of use | Richness of API | Language agnostic | Error handling
|===

== Webassembly

=== Screenshots first

=== Runtime loading

=== Error handling

=== Recap

|===
| Ease of use | Richness of API | Language agnostic | Error handling
|===

== Conclusion

The list of examples is quite long, but please help yourself:

- <{deskbar}>
- <{subtle}>
- <{subtle-rs}>
- <{touchjs}>
- <{rubtle}>
