---
layout: post
title: Embedding other languages
description: TBD
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: showcase extism rust lua ruby
categories: tech story
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/embedding_other_languages
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/embedding_other_languages
endif::[]
:figure-caption!:
:table-caption!:
:page-liquid:
:source-highlighter: highlight.js

:deskbar: https://sourceforge.net/projects/deskbar/
:subtle: https://github.com/unexist/subtle
:subtle-rs: https://github.com/unexist/subtle-rs
:touchjs: https://github.com/unexist/touchjs
:rubtle: https://github.com/unexist/rubtle
:extism: https://extism.org/
:wasm: https://webassembly.org/
:lua: https://www.lua.org/
:ruby: https://www.ruby-lang.org/en/
:foss: https://en.wikipedia.org/wiki/Free_and_open-source_software
:github: https://github.com/
:codeberg: https://codeberg.org/
:ilities: https://en.wikipedia.org/wiki/List_of_system_quality_attributes
:hackernews: https://news.ycombinator.com/
:clang: https://en.wikipedia.org/wiki/C_(programming_language)
:sharedobj: https://en.wikipedia.org/wiki/Shared_library
:segfault: https://en.wikipedia.org/wiki/Segmentation_fault
:dlopen: https://man7.org/linux/man-pages/man3/dlopen.3.html
:dlsym: https://man7.org/linux/man-pages/man3/dlsym.3.html
:setjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:longjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:goto: https://learn.microsoft.com/en-us/cpp/c-language/goto-and-labeled-statements-c

Coming up with a new software project is always a fun thing.
You start from a mere idea, like some quality-of-life thing as replacement for a piece of software that drives you nuts
or even something, that addresses a real problem, you tinker with it, play with it and move on.
And *if* everything goes really well you might end up with something quite usable.

This is by itself a great milestone, but wouldn't it be really great, if other people can also enjoy it?
Living in a {FOSS}[FOSS] world, publishing your code on
{Github}[Github]footnote:[Or {Codeberg}[Codeberg], if you don't want to contribute to AI] is just a stone
throw away.
This directly acts as a fine distribution channel, since you can just annouce it on pages like
{hackernews}[Hacker News] and call it a day.

Fast forward, your software is quite mature and among all the {ilities}[-ilities]
you've already addressed since you are a professional, *extensibility* hasn't been high up on your list and you kind of
lack behind user requests.

What about your software supports user contributed code?

image::timmy_turner.png[]

== Barebone

The year is 2004 and your project is obviously written in {clang}[C], so
the only real thing is to accept contribution in the form of even more C.
Since compiling the whole project from scratch everytime is quite annoying, you design your own plugin system with
your good old buddies `dlopen` and `dlsym`:

.{deskbar}[Deskbar]/deskbar/plug.c:97
[source,c]
----
DbPlugElement *element = NULL;

element = (DbPlugElement *) malloc (sizeof (DbPlugElement));

snprintf (buf, sizeof (buf), "%s/%s.so", PLUGIN_DIR, file);

element->handle = dlopen (buf, RTLD_LAZY); // <.>

if ((err = dlerror ())) // <.>
        {
                db_log_err ("Cannot load plugin `%s'\n", file);
                db_log_debug ("dlopen (): %s\n", err);

                free (element);

                return;
        }

/* Get entrypoint and call it */
entrypoint      = dlsym (element->handle, "db_plug_init"); // <.>
element->data   = (*entrypoint) (); // <.>
----
<.> Load a named {sharedobj}[shared object] from path with {dlopen}[dlopen]
<.> There is apparently a third buddy, rarely mentioned at all
<.> Find the address of a named entrypoint with {dlsym}[dlsym]
<.> Execute the entrypoint for profit


This opens some new ways of enriching your software and from your perspective it bases on an understandable and
approachable API.

.{deskbar}[Deskbar]/plugins/battery.c:107
[source,c]
----
static DbPlug plugin =
{
        "Battery",       /* Plugin name */
        battery_create,  /* Plugin create function */
        battery_update,  /* Plugin update function */
        battery_destroy, /* Plugin destroy function */

        &data,           /* Plugin data */
        NULL,            /* Plugin format */

        3600             /* Plugin update interval */
};

DbPlug *
db_plug_init (void)
{
        plug = &plugin; // <.>

        return (&plugin);
}
----
<.> Here we just pass a struct with function pointers to call the plugin

The learning curve is steep, and you quickly realize allowing custom code offers lots of freedom to enhance the
software, but like many double-edged sword can also introduce interesting surprises without special care.
{segfault}[Segmentation faults] inside our plugins can crash the whole application now, and without question you don't
want to violate the famous saying:

[quote,Linus Torvals,https://www.shutupmauro.com/]
[line-through]#Mauro, SHUT THE FUCK UP!# +
WE DO NOT BREAK USERSPACE!

Taking this advice by heart, you grab your dusty C-bible and skim to another pair of buddies, `setjmp` and `longjmp`:

.{deskbar}[Deskbar]/deskbar/plug.c:32
[source,c]
----
if (setjmp (env) == 0) // <.>
        plugfunc ();
else
        {
                db_log_mesg ("Ayyyee! Segmentation fault in plugin %s!\n",
                                                                 element->data->name); // <.>
                db_log_debug ("Call to %s () failed\n", name);
                db_plug_unload (element);

                return (1);
        }
----
<.> {setjmp}[setjmp] is a bit arcane magic, but essentially set a return markerfootnote:[Kind of a {goto}[goto label]] on the stack
<.> Well, different times back then..

.{deskbar}[Deskbar]/deskbar/sig.c:35
[source,c]
----
case SIGSEGV:
        longjmp (env, 1); // <.>

        db_log_debug ("Something went wrong! Segmentation fault!\n");
        db_sig_destroy ();

        abort ();
break;
----
<.> Once a segmentation fault occurs, unwind the stack with {longjmp}[longjmp] until the previous marker has been found
(if any) and try again

Once in place you feel content with the solution, reflect shortly on the impacts and release it to the wild.

|===
| Ease of use | Error handling | Language agnostic

| Requires compilation and linking
| Arcane - requires stack unwinding
| Plain C
|===

== Scripting languages

== Webassembly

== Conclusion

The list of examples is quite long, but please help yourself:

- <{deskbar}>
- <{subtle}>
- <{subtle-rs}>
- <{touchjs}>
- <{rubtle}>

[bibliography]
== Bibliography
