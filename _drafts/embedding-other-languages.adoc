---
layout: post
title: Embedding other languages
description: TBD
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: showcase extism rust lua ruby
categories: tech story
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/embedding_other_languages
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/embedding_other_languages
endif::[]
:figure-caption!:
:table-caption!:
:page-liquid:
:source-highlighter: highlight.js

:deskbar: https://sourceforge.net/projects/deskbar/
:subtle: https://github.com/unexist/subtle
:subtle-rs: https://github.com/unexist/subtle-rs
:touchjs: https://github.com/unexist/touchjs
:rubtle: https://github.com/unexist/rubtle
:extism: https://extism.org/
:wasm: https://webassembly.org/
:lua: https://www.lua.org/
:ruby: https://www.ruby-lang.org/en/
:github: https://github.com/
:codeberg: https://codeberg.org/

:ilities: https://en.wikipedia.org/wiki/List_of_system_quality_attributes
:maintainability: https://en.wikipedia.org/wiki/Maintainability
:correctness: https://en.wikipedia.org/wiki/Correctness_(computer_science)
:extensibility: https://en.wikipedia.org/wiki/Extensibility
:wikipedia: https://en.wikipedia.org
:foss: https://en.wikipedia.org/wiki/Free_and_open-source_software
:xlib: https://en.wikipedia.org/wiki/Correctness_(computer_science)
:gkrellm: https://gkrellm.srcbox.net/
:clang: https://en.wikipedia.org/wiki/C_(programming_language)
:autotools: https://en.wikipedia.org/wiki/GNU_Autotools
:linker: https://en.wikipedia.org/wiki/Linker_(computing)
:sharedobj: https://en.wikipedia.org/wiki/Shared_library
:dlopen: https://man7.org/linux/man-pages/man3/dlopen.3.html
:dlsym: https://man7.org/linux/man-pages/man3/dlsym.3.html
:convention: https://en.wikipedia.org/wiki/Convention_over_configuration

:hackernews: https://news.ycombinator.com/
:segfault: https://en.wikipedia.org/wiki/Segmentation_fault
:setjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:longjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:goto: https://learn.microsoft.com/en-us/cpp/c-language/goto-and-labeled-statements-c
:acpi: https://en.wikipedia.org/wiki/ACPI

There are many qualities modern software [line-through]#has to# *should* address especially when done properly.
Among the long list of {ilities}[-ilities], there are some boring
and pretty self-explanatory ones like {maintainability}[maintainability], some dogmatic
ones like {correctness}[correctness]footnote:[Correctnessily] and
also interesting ones, like {extensibility}[extensibility].

How a certain quality is best achieved depends on a plethora of things, but overall the targeted ones should match the
requirements and the budget to burn.
Stay put, we don't want to dwell on this longer than this introduction has to be, and we definitely also don't want to
go into detail about essentials ones, this is best done by something with affinity to lists like
{wikipedia}[Wikipedia].
Instead, we fast-forward directly to extensibility and see what this is all about.

According to Wikipedia extensibility revolves around future growth and proper design, but also mentions
scripting languages in the black box and scripting sounds about right for the remainder of this post.
So please be my guest while I delve a bit in my {FOSS}[FOSS]-history and lay out how different approaches and
why integrating scripting languages is a great idea.

image::go_wrong.png[]

== Barebone

Unbeknownst to my past self, I made my first experience with this kind of extensibility in 2004, when I started my long
journey with {xlib}[Xlib].
During that time I started a project called {deskbar}[deskbar] with the lofty goal to print
system information like cpu load, battery usage etc. directly onto the root window of the X session.
There were plenty of alternatives like {gkrellm}[GKrellM] readily available, but who likes pre-built
stuff when you can roll your own?

The initial idea was just to include everything in one binary, but I quickly discovered the ergonomics of re-compiling
and shipping everything together are annoying and I switched to a simple plugin system.

I would have loved to show some screenshots of deskbar in action here, but unfortunately after messing with
{autotools}[Autotools] and trying to compile old {clang}[C]-code with a modern compiler this is as far as I
gotfootnote:[..followed by two kilometres of error trace I am not in the mood to fix right now]:

[source,shell]
----
deskbar 0.1
-----------------
Build with ZLIB support.......: yes
Build with PNG support........: yes

Plugins:
Common Plugins................: Clock CPU Date
Battery Plugin................: no
XMMS Plugin...................: no // <.>
BMP Plugin....................: no // <.>
Debug Plugin..................: no

The binary will be installed in /usr/local/bin,
the lib in /usr/local/lib and the plugins
in /usr/local/lib/deskbar.

Try make now, good luck!
----
<.> https://en.wikipedia.org/wiki/XMMS[X Multimedia System (XMMS)]
<.> I can only guess - the plugin is just an empty stub that returns `NULL`

Nevertheless, this output clearly proves there has been a plugin system with conditional compilation and bases solely
on linker magic - how we are going to see next.

=== Linking late

Linking is complex topic, but in a nutshell during the linking process all intermediate parts (obj(ect)-files and
static libraries) are put together and rolled into a final executable binary or library:

.Linking process based on the diagram from {linker}
[plantuml]
----
rectangle "Static library (1)" as lib1
rectangle "Object file (2)" as obj1
rectangle "Object file" as obj2
rectangle "Linker" as linker
rectangle "Shared object (3)" as so
rectangle "Library (4)" as lib3
rectangle "Binary (4)" as bin

lib1 --> linker
obj1 --> linker
obj2 --> linker

linker --> lib3
linker --> so
linker --> bin
----
<1> Static libraries are directly included in the resulting artifact
<2> Object files are the compiled form of the source code
<4> {sharedobj}[Shared objects] can be loaded at runtime
<3> The artifact can either be a library type or an executable type

The interesting part here is the mentioned shared objects can also be dynamically loaded at runtime.

=== Runtime loading

Everything in C is a bit more complicated, so let us ignore the scar memory handling and just talk about the two
calls {dlopen}[dlopen] and {dlsym}[dlsym]:

.{deskbar}[deskbar]/deskbar/plug.c:97
[source,c]
----
DbPlugElement *element = NULL;

element = (DbPlugElement *) malloc (sizeof (DbPlugElement));

snprintf (buf, sizeof (buf), "%s/%s.so", PLUGIN_DIR, file);

element->handle = dlopen (buf, RTLD_LAZY); // <.>

if ((err = dlerror ())) // <.>
    {
        db_log_err ("Cannot load plugin `%s'\n", file);
        db_log_debug ("dlopen (): %s\n", err);

        free (element);

        return;
    }

/* Get entrypoint and call it */
entrypoint      = dlsym (element->handle, "db_plug_init"); // <.>
element->data   = (*entrypoint) (); // <.>
----
<.> Load the named {sharedobj}[shared object] from path
<.> There is apparently a third buddy, rarely mentioned at all
<.> Find the address of a named entrypoint
<.> Execute the entrypoint for profit

The entrypoint here is quite interesting, since the main application cannot know what is included in the plugin
or even what is exported.
Following the idea of {convention}[Convention over configuration], the defined contract here expects a symbol
named `db_plug_init` inside a plugin, which is called on load and *must* return a pointer to an initialized struct
of type `DBPlug`:

.{deskbar}[Deskbar]/plugins/battery.c:107
[source,c]
----
static DbPlug plugin =
{
    "Battery",       /* Plugin name */
    battery_create,  /* Plugin create function */
    battery_update,  /* Plugin update function */
    battery_destroy, /* Plugin destroy function */

    &data,           /* Plugin data */
    NULL,            /* Plugin format */

    3600             /* Plugin update interval */
};

DbPlug *
db_plug_init (void)
{
    plug = &plugin;

    return (&plugin); // <.>
}
----
<.> Pass the local address back to the main application

Once loaded the plugin is called in the given interval and can pass back data to the main application.

.{deskbar}[Deskbar]/plugins/battery.c:58
[source,c]
----
void
battery_update (void)
{
    int capacity    = 0,
    percent         = 0;

    char buf[100], state[20];

    /* Get battery info */
    if (!fd1)
        {
            snprintf (buf, sizeof (buf), "/proc/acpi/battery/BAT%d/state", bat_slot); // <.>

            fd1 = fopen (buf, "r");

            memset (buf, 0, sizeof (buf));
        }
    else
        fseek (fd1, 0, SEEK_SET);
...
}
----
<.> Here the battery plugin checks the battery values from the {acpi}[ACPI] interface

=== Error handling

The learning curve is steep, and you quickly realize allowing custom code offers lots of freedom to enhance the
software, but like so often with double-edged sword, there is an.. ehm another sharp edge?
{segfault}[Segmentation faults], the bane of software engineering, don't make halt inside plugins like they should, but
they wipe the board and kill the entire application!

Shocked as you are, you grab your dusty C-bible and look for ways to mitigate this, since it goes without question you
don't want to violate the famous saying:

[quote,Linus Torvals,https://www.shutupmauro.com/]
[line-through]#Mauro, SHUT THE FUCK UP!# +
WE DO NOT BREAK USERSPACE!

Taking this advice by heart, you basically dive into the book and read on.

image::few_hours_later.png[]

Right there, in the forbidden section of the book, you stumble upon another pair of
buddies - `setjmp` and `longjmp`:

.{deskbar}[Deskbar]/deskbar/plug.c:32
[source,c]
----
if (setjmp (env) == 0) // <.>
        plugfunc ();
else
        {
                db_log_mesg ("Ayyyee! Segmentation fault in plugin %s!\n",
                                                                 element->data->name); // <.>
                db_log_debug ("Call to %s () failed\n", name);
                db_plug_unload (element);

                return (1);
        }
----
<.> {setjmp}[setjmp] is a bit arcane magic, but essentially sets a return markerfootnote:[Kind of a {goto}[goto label]] on the stack
<.> Well, different times back then..

.{deskbar}[Deskbar]/deskbar/sig.c:35
[source,c]
----
case SIGSEGV:
        longjmp (env, 1); // <.>

        db_log_debug ("Something went wrong! Segmentation fault!\n");
        db_sig_destroy ();

        abort ();
break;
----
<.> Once a segmentation fault occurs, unwind the stack with {longjmp}[longjmp] until the previous marker has been found
(if any) and try again

Once in place you feel content with the solution, reflect shortly on the impacts and release it to the wild.

|===
| Ease of use | Richness of API | Language agnostic | Error handling

| Requires compilation and linking
| Language + host provided
| No, requires plugins to be in Cfootnote:[Technically everything that can be linked, so other languages might actually be possible here]
| Arcane - requires stack unwinding
|===

== Scripting languages

Still happy with the success of the previous project, you think the previous great thing is lacking in design and
ambition and you devise something new.


|===
| Ease of use | Richness of API | Language agnostic | Error handling
|===

== Webassembly

|===
| Ease of use | Richness of API | Language agnostic | Error handling
|===

== Conclusion

The list of examples is quite long, but please help yourself:

- <{deskbar}>
- <{subtle}>
- <{subtle-rs}>
- <{touchjs}>
- <{rubtle}>

[bibliography]
== Bibliography
