---
layout: post
title: Fun with embeddability
description: Personal journey through 20+ years of FOSS-projects under the umbrella of how to embed scripting languages for fun.
#date: %%%DATE%%%
#last_updated: %%%DATE%%%
author: Christoph Kappel
tags: showcase c rust obj-c lua ruby javascript duktape extism
categories: tech
toc: true
---
ifdef::asciidoctorconfigdir[]
:imagesdir: {asciidoctorconfigdir}/../assets/images/fun_with_embeddability
endif::[]
ifndef::asciidoctorconfigdir[]
:imagesdir: /assets/images/fun_with_embeddability
endif::[]
:figure-caption!:
:table-caption!:
:page-liquid:
:source-highlighter: highlight.js

:subtle-rs: https://github.com/unexist/subtle-rs
:rubtle: https://github.com/unexist/rubtle
:extism: https://extism.org/
:wasm: https://webassembly.org/

:embeddability: https://en.wiktionary.org/wiki/embeddability
:ilities: https://en.wikipedia.org/wiki/List_of_system_quality_attributes
:maintainability: https://en.wikipedia.org/wiki/Maintainability
:correctness: https://en.wikipedia.org/wiki/Correctness_(computer_science)
:extensibility: https://en.wikipedia.org/wiki/Extensibility
:wikipedia: https://en.wikipedia.org
:foss: https://en.wikipedia.org/wiki/Free_and_open-source_software
:xlib: https://en.wikipedia.org/wiki/Correctness_(computer_science)
:deskbar: https://github.com/unexist/deskbar
:gkrellm: https://gkrellm.srcbox.net/
:clang: https://en.wikipedia.org/wiki/C_(programming_language)
:sourceforge: https://sourceforge.net/
:deskbarsf: https://deskbar.sourceforge.net
:autotools: https://en.wikipedia.org/wiki/GNU_Autotools
:linker: https://en.wikipedia.org/wiki/Linker_(computing)
:sharedobj: https://en.wikipedia.org/wiki/Shared_library
:dlopen: https://man7.org/linux/man-pages/man3/dlopen.3.html
:dlsym: https://man7.org/linux/man-pages/man3/dlsym.3.html
:convention: https://en.wikipedia.org/wiki/Convention_over_configuration
:acpi: https://en.wikipedia.org/wiki/ACPI
:segfault: https://en.wikipedia.org/wiki/Segmentation_fault
:torvalds: https://en.wikipedia.org/wiki/Linus_Torvalds
:rust: https://rust-lang.org/
:setjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:longjmp: https://man7.org/linux/man-pages/man3/setjmp.3.html
:goto: https://learn.microsoft.com/en-us/cpp/c-language/goto-and-labeled-statements-c
:signal: https://man7.org/linux/man-pages/man7/signal.7.html
:subtle: https://github.com/unexist/subtle
:lua: https://www.lua.org/
:ruby: https://www.ruby-lang.org/en/
:issue1: https://subtle.de/issues/1
:wow: https://worldofwarcraft.blizzard.com/en-us/
:sublets: https://projects.unexist.dev/projects/subtle/wiki/Writing_sublets
:patchgist: https://gist.github.com/unexist/4ee3cb94c91555b1bac01e23f992b9e4
:luapcall: https://www.lua.org/pil/25.2.html
:luagetglobal: https://www.lua.org/manual/2.4/node16.html
:luagettable: https://www.lua.org/pil/25.1.html
:luapushstring: https://www.lua.org/pil/24.2.1.html
:luatostring: https://www.lua.org/pil/24.2.2.html
:luapcall: https://www.lua.org/pil/25.2.html
:sublets: https://github.com/unexist/sublets
:metaprog: https://en.wikipedia.org/wiki/Metaprogramming
:styles: https://subtle.de/projects/subtle/wiki/Styles
:dsl: https://en.wikipedia.org/wiki/Domain-specific_language
:touchjs: https://github.com/unexist/touchjs
:macos: https://www.apple.com/os/macos/
:touchbar: https://support.apple.com/guide/mac-help/use-the-touch-bar-mchlbfd5b039/mac
:accessapi: https://github.com/unexist/touchjs
:duktape: https://duktape.org/
:obj-c: https://en.wikipedia.org/wiki/Objective-C

*Embeddability*?
I am quite certain this is in fact an {embeddability}[english word], but you probably won't find it
among the other {ilities}[-ilities] of qualities, software might want to address.
Definitely among it, there are some boring and pretty self-explanatory ones like
{maintainability}[maintainability], even some dogmatic ones like
{correctness}[correctness]footnote:[Correctness-ily?], but fortunately also funnier ones like
{extensibility}[extensibility].

And like to often, how a certain quality is best achieved depends on a plethora of things, but
according to {Wikipedia}[Wikipedia], one to archive extensibility is to use scripting languages
and everything finally comes together: +
They can be quite embeddable.

So in case you have some time to kill, join me on a lengthy journey through 20+ years of personal
{FOSS}[FOSS]-history.
This is going to fun and we are having a look at d approaches of embedding and also see why this
is always great idea.

.https://knowyourmeme.com/photos/930538-the-fairly-oddparents
image::meme-go_wrong.png[Meme Go Wrong]

== Barebone

Unbeknownst to my past self, I made my first experience with this kind of extensibility in 2004,
when I started my long journey with {xlib}[Xlib].
During that time I started a project called {deskbar}[deskbar] with the lofty goal to print system
information like cpu load, battery usage etc. directly onto the root window of the X session.
There were plenty of alternatives like {gkrellm}[GKrellM] readily available, but ho likes pre-built
stuff when you can roll your own?

The initial idea was just to include everything in one binary, but I quickly discovered the
ergonomics of re-compiling and shipping everything together are annoying and I switched to a simple
plugin system.

=== Screenshots first

I would have loved to show some screenshots of deskbar in action here, but unfortunately after
messing with {autotools}[Autotools] and trying to compile old {clang}[C]-code with a modern compiler
this is as far as I gotfootnote:[..followed by kilometres of error trace I wasn't in the mood to
fix right now]:

.Build #1 attempt of {deskbar}[deskbar]
[source,shell]
----
$ ./configure && make
deskbar 0.1
-----------------
Build with ZLIB support.......: yes
Build with PNG support........: yes

Plugins:
Common Plugins................: Clock CPU Date
Battery Plugin................: no
XMMS Plugin...................: no // <.>
BMP Plugin....................: no // <.>
Debug Plugin..................: no

The binary will be installed in /usr/local/bin,
the lib in /usr/local/lib and the plugins
in /usr/local/lib/deskbar.

Try make now, good luck!

make  all-recursive
make[1]: Entering directory '/home/unexist/build/deskbar-0.1'

# --- %< --- snip --- %< ---

/bin/bash ../libtool  --tag=CC   --mode=compile gcc -DHAVE_CONFIG_H -I. -I..     -g -O2  -I/usr/include -I/usr/include -MT htable.lo -MD -MP -MF .deps/htable.Tpo -c -o htable.lo htable.c
libtool: compile:  gcc -DHAVE_CONFIG_H -I. -I.. -g -O2 -I/usr/include -I/usr/include -MT htable.lo -MD -MP -MF .deps/htable.Tpo -c htable.c  -fPIC -DPIC -o .libs/htable.o
In file included from htable.c:2:
/usr/include/string.h:466:13: error: storage class specified for parameter 'explicit_bzero'
  466 | extern void explicit_bzero (void *__s, size_t __n) __THROW __nonnull ((1)) // <.>
      |             ^~~~~~~~~~~~~~
/usr/include/string.h:471:14: error: make[2]: *** [Makefile:457: htable.lo] Error 1
make[2]: Leaving directory '/home/unexist/build/deskbar-0.1/libdeskbar'
make[1]: *** [Makefile:479: all-recursive] Error 1
make[1]: Leaving directory '/home/unexist/build/deskbar-0.1'
make: *** [Makefile:374: all] Error 2storage class specified for parameter 'strsep'
  471 | extern char *strsep (char **__restrict __stringp,
      |              ^~~~~~
/usr/include/string.h:478:14: error: storage class specified for parameter 'strsignal'
  478 | extern char *strsignal (int __sig) __THROW;
      |              ^~~~~~~~~

# --- %< --- snip --- %< ---

make[2]: *** [Makefile:457: htable.lo] Error 1
make[2]: Leaving directory '/home/unexist/build/deskbar-0.1/libdeskbar'
make[1]: *** [Makefile:479: all-recursive] Error 1
make[1]: Leaving directory '/home/unexist/build/deskbar-0.1'
make: *** [Makefile:374: all] Error 2
----
<.> https://en.wikipedia.org/wiki/XMMS[X Multimedia System (XMMS)]
<.> I can only guess - the plugin is just an empty stub that returns `NULL`
<.> Yes, oh well...

Nevertheless, this output clearly proves there has been a plugin system with conditional
compilation, which bases solely on linking magic, and we have to move on.

.Edit
****
I dug a bit further and stumbled upon my old project page on {sourceforge}[SourceForge], which
luckily still provides sftp access to the project page:

<{deskbarsf}>

And with even more luck, although the page is a bit empty, the file listing included screenshots:

.Screenshot of {deskbar}[deskbar-0.7c (1/2)]
image::deskbar-05-05-2005.png[Screenshot of deskbar #1]
.Screenshot of {deskbar}[deskbar-0.7c (2/2)]
image::deskbar-shot.png[Screenshot of deskbar #2]
****

=== Runtime loading

Everything in C is a bit more complicated, so let us ignore the scary memory handling and just
talk about the two interesting calls {dlopen}[dlopen] and {dlsym}[dlsym]:

.{deskbar}[deskbar]/deskbar/plug.c:97
[source,c]
----
DbPlugElement *element = NULL;

element = (DbPlugElement *) malloc (sizeof (DbPlugElement));

snprintf (buf, sizeof (buf), "%s/%s.so", PLUGIN_DIR, file);

element->handle = dlopen (buf, RTLD_LAZY); // <.>

if ((err = dlerror ())) // <.>
    {
        db_log_err ("Cannot load plugin `%s'\n", file);
        db_log_debug ("dlopen (): %s\n", err);

        free (element);

        return;
    }

/* Get entrypoint and call it */
entrypoint      = dlsym (element->handle, "db_plug_init"); // <.>
element->data   = (*entrypoint) (); // <.>
----
<.> Load the named shared object from path
<.> There is apparently a third call, but rarely mentioned at all
<.> Find the address of a named entrypoint
<.> Execute the entrypoint for profit

.Excursion: Linking in a Nutshell
****
Linking is complex topic, but in a nutshell during the linking process all intermediate parts
obj(ect)-files and static libraries) are put together and rolled into a final executable binary or
library:

.Linking process based on the diagram from {linker}
[plantuml]
----
'!theme unexist from {{ site.asciidoctor_attributes.plantumldir }}

skinparam linetype ortho
skinparam nodesep 20
skinparam ranksep 20

rectangle "Static library (1)" as lib1
rectangle "Object file (2)" as obj1
rectangle "Object file" as obj2
rectangle "Linker" as linker
rectangle "Shared object (3)" as so
rectangle "Library (4)" as lib3
rectangle "Binary (4)" as bin

lib1 --> linker
obj1 --> linker
obj2 --> linker

linker --> lib3
linker --> so
linker --> bin
----
<1> Static libraries are directly included in the resulting artifact
<2> Object files are the compiled form of the source code
<4> {sharedobj}[Shared objects] can be loaded at runtime
<3> The result can either be a shared, library or executable type
****

The entrypoint here is quite interesting, since the main application cannot know what is included
in the plugin or even what is exported.
Following the idea of {convention}[Convention-over-configuration], the defined contract here
expects a symbol named `db_plug_init` inside a plugin, which is called on load and *must* return
a pointer to an initialized struct of type `DBPlug`:

.{deskbar}[deskbar]/plugins/battery.c:107
[source,c]
----
static DbPlug plugin =
{
    "Battery",       /* Plugin name */
    battery_create,  /* Plugin create function */
    battery_update,  /* Plugin update function */
    battery_destroy, /* Plugin destroy function */

    &data,           /* Plugin data */
    NULL,            /* Plugin format */

    3600             /* Plugin update interval */
};

DbPlug *
db_plug_init (void)
{
    plug = &plugin;

    return (&plugin); // <.>
}
----
<.> Pass the local address back to the main application

Once loaded the plugin is called in the given interval and can exchange data with the main
application.

.{deskbar}[deskbar]/plugins/battery.c:58
[source,c]
----
void
battery_update (void)
{
    int capacity    = 0,
    percent         = 0;

    char buf[100], state[20];

    /* Get battery info */
    if (!fd1)
        {
            snprintf (buf, sizeof (buf), "/proc/acpi/battery/BAT%d/state", bat_slot); // <.>

            fd1 = fopen (buf, "r");

            memset (buf, 0, sizeof (buf));
        }
    else
        fseek (fd1, 0, SEEK_SET);

    /* --- %< --- snip --- %< --- */
}
----
<.> Here the battery plugin checks the battery values from the {acpi}[ACPI] interface

Allowing contribution this way is really easy and powerful, but like so often comes with a catch.
{segfault}[Segmentation faults], the bane of software
engineering, don't make halt inside plugins like they should, but they wipe the board and kill the
entire application.

I think {torvalds}[Torvalds] nailed it perfectly and I agree this should never happen:

[quote,Linus Torvals,https://www.shutupmauro.com/]
[line-through]#Mauro, SHUT THE FUCK UP!# +
WE DO NOT BREAK USERSPACE!

I am kind of surprised how far I went in trying to keep problems in the plugin at bay.
The original project included memory managementfootnote:[Check `mem.c` if you are curious] for
plugins and also applied the next two calls I'd like to demonstrate next.

=== Error handling

Handling segmentation faults properly is really difficult and the common sense is normally catch
them and exit gracefully when possible.
Still, there are cases when faults _can_ be safely ignored and a plugin interface is a paragon for
this.

This can be done with the pair of {setjmp}[setjmp] and {longjmp}[longjmp], which behave for most
practical senses like a {goto}[goto] on steroids:

.{deskbar}[deskbar]/deskbar/plug.c:25
[source,c]
----
static int¬                                                                                                                                                                                                                                                                                                                                                              26 save_call (DbPlugElement *element,¬
save_call (DbPlugElement *element,
    DbPlugFunc plugfunc
    const char *name)
{
    if (plugfunc)
        {
            if (setjmp (env) == 0) // <.>
                plugfunc ();
            else
                {
                    db_log_mesg ("Ayyyee! Segmentation fault in plugin %s!\n", element->data->name); // <.>
                    db_log_debug ("Call to %s () failed\n", name);
                    db_plug_unload (element);

                    return (1);
                }
        }

    return (0);
}
----
<.> Save stack and instruction pointer for later use when it is for the first time; otherwise ditch
the plugin
<.> Well, different times back then..

When the application receives the bad {signal}[signal] `SISEGV`, it checks if there are stored stack
and instruction values and rewinds the stack accordingly:

.{deskbar}[deskbar]/deskbar/sig.c:35
[source,c]
----
static void
sig_handler (int sig)
{
    switch (sig)
        {
            case SIGSEGV:
                longjmp (env, 1); // <.>

                db_log_debug ("Something went wrong! Segmentation fault!\n");
                db_sig_destroy ();

                abort ();
            break;

    /* --- %< --- snip --- %< --- */
}
----
<.>  Check the values and pass control if necessary; otherwise just bail out

=== Recap

|===
| Ease of use | Richness of API | Language agnostic | Error handling | Performance

| Low; requires compilation and linking
| The API is simple, but can be enriched by the host
| No; requires plugins to be in Cfootnote:[Technically everything that can be linked, so other
languages _might_ actually be possible here. Dare I to try {rust}[Rust]?]
| Arcane; requires stack unwinding
| Runs natively, so pretty fast
|===

== Scripting languages

Three years later in 2007 I continued on building upon my Xlib skills and started my long-lasting
project {subtle}[subtle].

Over the years there have been many major breaking changes, from the initial design to the state
it currently is in.
Two of the post-related changes were the integration of the scripting language {lua}[Lua] and its
later replacement with{Ruby}[Ruby] after a few years in this glorious {issue1}[issue #1].

=== Integrating Lua

I am not entire sure where I picked Lua up, but I never played {wow}[WoW] so probably from somewhere
else and I can only talk about the state and API from back then.

Adding a scripting language solves quite a few problems:

- File loading and parsing can be offloaded to the language core
- The language itself comes with a basic subset of things you can do with it
- Bonus: Config handling can also be directly offloaded

==== Time for Screenshots

My attempt of trying to compile the project and provide an actual screenshot this time ended
quickly as well:

.Build attempt #1 of {subtle}[subtle-0.7b]
[source,shell]
----
$ ./configure && make

# --- %< --- snip --- %< ---

subtle 0.7b
-----------------
Binary....................: /usr/local/bin
Sublets...................: /usr/local/share/subtle
Config....................: /usr/local/etc/subtle

Debugging messages........:

Try make now, good luck!

make  all-recursive
make[1]: Entering directory '/home/unexist/build/subtle-0.7b'
Making all in src

# --- %< --- snip --- %< ---

if gcc -DHAVE_CONFIG_H -I. -I. -I.. -I..   -g -O2  -I/usr/include/lua5.1  -g -O2  -MT subtle-event.o -MD -MP -MF ".deps/subtle-event.Tpo" -c -o subtle-event.o `test -f 'event.c' || echo './'`event.c; \
then mv -f ".deps/subtle-event.Tpo" ".deps/subtle-event.Po"; else rm -f ".deps/subtle-event.Tpo"; exit 1; fi
event.c: In function ‘subEventLoop’:
event.c:352:57: error: implicit declaration of function ‘subSubletSift’; did you mean ‘subSubletKill’? [-Wimplicit-function-declaration]
  352 |                                                         subSubletSift(1);
      |                                                         ^~~~~~~~~~~~~
      |                                                         subSubletKill
make[2]: *** [Makefile:310: subtle-event.o] Error 1
make[2]: Leaving directory '/home/unexist/build/subtle-0.7b/src'
make[1]: *** [Makefile:233: all-recursive] Error 1
make[1]: Leaving directory '/home/unexist/build/subtle-0.7b'
make: *** [Makefile:171: all] Error 2
----

This is kind of embarrassing for an official release and really have to question the quality in
retrospect, but this won't stop us now.

.https://knowyourmeme.com/memes/spongebob-time-cards
image::meme-few_hours_later.png[Meme Few Hours Laters]

After a dive into the code there were some obviously problems and also blatant oversights and if
you are interested in the shameful truth here is silly patch:

<{patchgist}>

And without further ado here is finally the screenshot of the scripting part in action, before we
dive into how this is actually done under the hood:

.Screenshot of {subtle}[subtle-0.7b] (1/2)
image::subtle-0.7b.png[Screenshot of subtle #1]

==== Runtime loading

Starting with the easy part, offloading the config handling was one of the first things I did and
this made a config like this entirely possible:

.{subtle}[subtle-0.7b]/config/config.lua:1
[source,lua]
----
-- Options config
font = {
    face    = "lucidatypewriter",  -- Font face for the text
    style   = "medium",            -- Font style (medium|bold|italic)
    size    = 12                   -- Font size
}

-- Color config
colors = {
    font       = "#ffffff",        -- Color of the font
    border     = "#ffffff",        -- Color of the border/tiles
    normal     = "#CFDCE6",        -- Color of the inactive windows
    focus      = "#6096BF",        -- Color of the focussed window
    shade      = "#bac5ce",        -- Color of shaded windows
    background = "#596F80"         -- Color of the root background
}

-- --- %< --- snip --- %< ---
----

Essentially the C API of Lua is a stack machine and the interaction with is through pushing and
popping values onto and from the
stack.footnote:[Haven't touched Lua for ages, but apparently this is still true.]

I've removed a bit of the fluff and checks upfront, so we can have a quick glance at the config
loading and jump further into nitty-gritty details:

.{subtle}[subtle-0.7b]/src/lua.c:150
[source,c]
----
subLogDebug("Reading `%s'\n", buf);
if(luaL_loadfile(configstate, buf) || lua_pcall(configstate, 0, 0, 0)) // <.>
    {
        subLogDebug("%s\n", (char *)lua_tostring(configstate, -1));
        lua_close(configstate);
        subLogError("Can't load config file `%s'.\n", buf);
    }

/* Parse and load the font */¬
face  = GetString(configstate, "font", "face", "fixed"); // <.>
style = GetString(configstate, "font", "style", "medium");
size  = GetNum(configstate, "font", "size", 12);
----
<.> Internal calls to load the config file and just execute it in a safe way {luapcall}[pcall]
<.> Once everything is stored inside `configstate` we fetch required values

.{subtle}[subtle-0.7b]/src/lua.c:47+72
[source,c]
----
#define GET_GLOBAL(configstate) do { \ // <.>
    lua_getglobal(configstate, table); \ // <.>
    if(lua_istable(configstate, -1)) \
        { \
            lua_pushstring(configstate, field); \ // <.>
            lua_gettable(configstate, -2); \
        } \
} while(0)

static char *
GetString(lua_State *configstate,
    const char *table,
    const char *field,
    char *fallback)
{
    GET_GLOBAL(configstate);
    if(!lua_isstring(configstate, -1)) // <.>
        {
            subLogDebug("Expected string, got `%s' for `%s'.\n", lua_typename(configstate, -1), field);
            return(fallback);
        }
    return((char *)lua_tostring(configstate, -1)); // <.>
}
----
<.> Blocks in C macros require this fancy hack; probably best to skip over it
<.> We check and fetch a tablefootnote:[There are jokes about how every type in Lua is a table..]
<.> Push the string onto the current stack
<.> Pull the value with index -2 from the stack
<.> And convert it to our desired format

.Excursion: Playing with the stack
****
If you haven't played with stack machines before it might be a bit difficult to follow what it is
done, so here is a small break down how the API works:

.Stack handling diagram
[plantuml]
----
'!theme unexist from {{ site.asciidoctor_attributes.plantumldir }}

skinparam linetype ortho
skinparam nodesep 20
skinparam ranksep 20

together {
    rectangle "lua_getglobal (1)" as l1
    stack "Stack (1)" as s1
}

together {
    rectangle "lua_pushstring (2)" as l2
    stack "Stack (2)" as s2 {
        rectangle "[-1] font\n(Table)"
    }
}

together {
    rectangle "lua_gettable (3)" as l3
    stack "Stack (3)" as s3 {
        rectangle "[-1] font\n(Table)" as s3_font
        rectangle "[-2] face\n(String)"  as s3_face
    }
}

together {
    rectangle "lua_tostring (4)" as l4
    stack "Stack (4)" as s4 {
        rectangle "[-1] lucidatypewriter\n(String)" as s4_luci
    }
}

legend right
    | (1) | Step # |
    | [-1] | Stack position |
    | (String) | Data type |
endlegend

' Placement
s3_font -[hidden]d-> s3_face

s1 -[hidden]r-> s2
s2 -[hidden]r-> s3
s3 -[hidden]r-> s4

l1 -[hidden]d-> s1
l2 -[hidden]d-> s2
l3 -[hidden]d-> s3
l4 -[hidden]d-> s4

' Arrows
l1 -r--> l2
l2 -r--> l3
l3 -r--> l4
----
<1> Call {luagetglobal}[lua_getglobal] to put the table `font` onto the stack at position
`-1` footnote:[Lua uses negative numbers ]
<2> Call {luapushstring}[lua_pushstring] to put the string `face` of the desired row name on the
stack at position `-1`
<3> Call {luagettable}[lua_gettable] to consume both values and fetch the row by given name from
the table and put the result at stack position `-1`
<4> Call {luatostring}[lua_tostring] to convert on the stack at position `-1` to string if possible
****

==== Error handling

Loading of plugins at runtime is basically the same as loading the config upfront, so let us just
move on to error handling, which is slightly more interesting.
It is probably no surprise, but the API is quite rudimentary and the handling of the stack and
calls in case of an actual error is up to person to embed the engine.

Before we can see how this is done, let us quickly check how our battery plugin evolved from the
arcane version in C to the Lua glory.
First of all, plugins have been rebranded to {sublets}[sublets]footnote:[You probably get the pun..]
and it (at least to me) became a bit more readable:

.{subtle}[subtle-0.7b]/sublets/battery.lua:30
[source,lua]
----
-- Get remaining battery in percent
function battery:meter() // <.>
    local f = io.open("/proc/acpi/battery/BAT" .. battery.slot .. "/state", "r")
    local info = f:read("*a")
    f:close()

    _, _, battery.remaining = string.find(info, "remaining capacity:%s*(%d+).*")
    _, _, battery.rate      = string.find(info, "present rate:%s*(%d+).*")
    _, _, battery.state     = string.find(info, "charging state:%s*(%a+).*")

    return(math.floor(battery.remaining * 100 / battery.capacity))
end
----
<.> The `:` here is used as a kind of namespace separator this is handled as a global table
called `battery` with the entry `meter`.

Once the sublet is loaded and initialized we can just call it analogue to our `save_call` from
before:

.{subtle}[subtle-0.7b]/src/lua.c:345
[source,c]
----
void
subLuaCall(SubSublet *s)
{
    if(s)
        {
            lua_settop(state, 0); // <.>
            lua_rawgeti(state, LUA_REGISTRYINDEX, s->ref);
            if(lua_pcall(state, 0, 1, 0)) // <.>
                {
                    if(s->flags & SUB_SUBLET_FAIL_THIRD) // <.>
                        {
                            subLogWarn("Unloaded sublet (#%d) after 3 failed attempts\n", s->ref);
                            subSubletDelete(s);
                            return;¬
                        }
                    else if(s->flags & SUB_SUBLET_FAIL_SECOND) s->flags |= SUB_SUBLET_FAIL_THIRD;
                    else if(s->flags & SUB_SUBLET_FAIL_FIRST) s->flags |= SUB_SUBLET_FAIL_SECOND;

                    subLogWarn("Failed attempt #%d to call sublet (#%d).\n",
                        s->flags & SUB_SUBLET_FAIL_SECOND) ? 2 : 1, s->ref);
                }

            switch(lua_type(state, -1)) // <.>
                {
                    case LUA_TNIL: subLogWarn("Sublet (#%d) does not return any usuable value\n", s->ref); break;
                    case LUA_TNUMBER: s->number = (int)lua_tonumber(state, -1); break;
                    case LUA_TSTRING:
                        if(s->string) free(s->string);
                        s->string = strdup((char *)lua_tostring(state, -1));
                        break;
                    default:
                        subLogDebug("Sublet (#%d) returned unkown type %s\n", s->ref, lua_typename(state, -1));
                        lua_pop(state, -1);
                    }
                }
        }
}
----
<.> A bit stack setup and retrieval via upfront
<.> Here we call {luapcall}[lua_pcall], which abstracts and hides the nasty `setjmp` and `longjmp`
handling from us
<.> Looks like I discovered bitflags there and utilized it for error handling
<.> Type handling for a more generic interface

=== Integrating Ruby

Moving fast-forward with subtle, I've replaced Lua with {Ruby}[Ruby] after a
while and this is an entirely different way of integration, but let us just stick to our recipe
here and do one thing after another.

==== Time for Screenshots

This time it is quite easy to find and even to make a nice screenshot of subtle, since I am using
it on a daily on several devices and don't have to mess with outdated and broken
buildsfootnote:[Well, technically this isn't true, if you consider the outdated Ruby version, but..].

.Screenshot of {subtle}[subtle-0.12.6606] (2/2)
image::subtle-0.12.6606.png[screenshot of subtle #2]

==== Runtime loading

So when we finally start subtle everything comes together, and we see the pieces from the other
solutions before, therefore are there any objections when we just increase the pace a bit for
similarities and go into detail for new stuff?

.https://knowyourmeme.com/memes/spongebob-time-cards
image::meme-wall_of_text.png[Meme Wall of Text]

Just feel free to skip the next few listings and join us later and for the ones remaining here
is the triplet of loading info, config and battery thingy:


.Running of {subtle}[subtle-0.12.6606]
[source,shell]
----
$ subtle -d :2 -c subtle.rb -s sublets
subtle 0.12.6606 - Copyright (c) 2005-present Christoph Kappel
Released under the GNU General Public License
Compiled for X11R0 and Ruby 2.7.8
Display (:2) is 640x480
Running on 1 screen(s)
ruby: warning: already initialized constant TMP_RUBY_PREFIX
Reading file `subtle.rb'
Reading file `sublets/battery.rb'
Loaded sublet (battery)
Reading file `sublets/fuzzytime.rb'
Loaded sublet (fuzzytime)
----

The config looks a bit different, mainly because we are now using a custom {DSL}[DSL], but we are
going to cover this part in detail shortly, promised.

.{subtle}[subtle-0.12.6606]/data/subtle.rb:94
[source,ruby]
----
# Style for all style elements
style :all do # <.>
    foreground  "#757575"
    background  "#202020"
    icon        "#757575"
    padding     0, 3
    font        "-*-*-*-*-*-*-14-*-*-*-*-*-*-*"
    #font        "xft:sans-8"
end

# Style for the all views
style :views do # <.>
    # Style for the active views
    style :focus do
        foreground  "#fecf35"
    end

    # --- %< --- snip --- %< ---
end
----
<.> Ruby is famous for {metaprog}[metaprogramming] and we obviously make have use of it here
<.> {Styles}[Styles] are a CSS-like way of configuring colors in subtle - batteries and
inheritance included

And lastly, a quick glimpse into the battery sublet, which naturally also makes use of the
mentioned DSL:

.{sublets}[battery-0.9]/battery.rb:64
[source,ruby]
----
on :run do |s|
    begin # <.>
        now     = IO.readlines(s.now).first.to_i
        state   = IO.readlines(s.status).first.chop
        percent = (now * 100 / s.full).to_i

        # --- %< --- snip --- %< ---

        # Select icon for state
        icon = case state # <.>
            when "Charging"  then :ac
            when "Discharging"
                case percent
                    when 67..100 then :full
                    when 34..66  then :low
                    when 0..33   then :empty
                end
            when "Full"          then :ac
            else                      :unknown
        end

        s.data = "%s%s%s%d%%" % [
            s.color_icon ? s.color : s.color_def, s.icons[icon],
            s.color_text ? s.color : s.color_def, percent
            ]
        rescue => err # Sanitize to prevent unloading
            s.data = "subtle"
        p err
    end
end
----
<.> Ruby comes with exception handling and this eases the whole scripting part greatly
<.> Aww, this kind of reminds of Rust <3

So when we talk about metaprogramming, what exactly is different here?
If you have a closer look at the previous examples, we mostly defined data structures and
methods there, which were later collected during load and/or actually called of the host
application.
In other words our scripts defined an API by the rules of the host application, which then runs it.
Now with metaprogramming, we turn this around and define methods to provide an API for our
scripts and let them call it.

The Ruby integration in subtle is quite vast, and I'd like to show so many cool things in it, but
time is precious, as is any attention span.
So we have to cut a few corners here and there and follow loads of [line-through]#indirection#
abstraction, but I think we better stay with the styles excerpt from above.

Loading styles from the config consists of following basic building blocks:

.{subtle}[subtle-0.12.6606]/src/subtle/ruby.c:3161
[source,c]
----
void subRubyInit(void) {
    VALUE config = Qnil, options = Qnil, sublet = Qnil;

    /* --- %< --- snip --- %< --- */

    config = rb_define_class_under(mod, "Config", rb_cObject); // <.>

    /* Class methods */¬
    rb_define_method(config, "style", RubyConfigStyle, 1); // <.>

    /* --- %< --- snip --- %< --- */
}
----
<.> Define a holding class for our method definition
<.> Define the actual method `style` and bind it to `RubyConfigStyle`

.{subtle}[subtle-0.12.6606]/src/subtle/ruby.c:3239
[source,c]
----
void subRubyLoadConfig(void) {
    VALUE klass = Qnil;

    /* Load supplied config or default */
    klass = rb_const_get(mod, rb_intern("Config")); // <.>
    config_instance = rb_funcall(klass, rb_intern("new"), 0, NULL);
    rb_gc_register_address(&config_instance); // <.>

    if (Qfalse == RubyConfigLoadConfig(config_instance,¬
        rb_str_new2(subtle->paths.config ? subtle->paths.config : PKG_CONFIG))) { // <.>
        subSubtleFinish();

        exit(-1);¬
    } else if (subtle->flags & SUB_SUBTLE_CHECK) {
        printf("Syntax OK\n");
    }

    /* --- %< --- snip --- %< --- */
}
----
<.> Call back our config class and create a new instance
<.> Take care, that the internal garbage collector doesn't get rid of it
<.> Wrap it again and continue in the next snippet

.{subtle}[subtle-0.12.6606]/src/subtle/ruby.c:1688
[source,c]
----
static VALUE RubyConfigLoadConfig(VALUE self, VALUE file) {
    /* --- %< --- snip --- %< --- */

    printf("Reading file `%s'\n", buf);

    /* Carefully load and eval file */
    rargs[0] = rb_str_new2(buf);
    rargs[1] = self;

    rb_protect(RubyWrapEvalFile, (VALUE) &rargs, &state); // <.>
    if (state) {
        subSubtleLogWarn("Cannot load file `%s'\n", buf);
        RubyBacktrace();

        return Qfalse;
    }

    return Qtrue;
} /* }}} */¬
----
<.> Ruby uses its own version of `setjmp` and `longjmp`, so wrap everything up and pass it over

.{subtle}[subtle-0.12.6606]/src/subtle/ruby.c:1442
[source,c]
----
/* RubyWrapEvalFile */
static VALUE RubyWrapEvalFile(VALUE data) {
    VALUE *rargs = (VALUE *) data, rargs2[3] = {Qnil};

    /* Wrap data */
    rargs2[0] = rb_funcall(rb_cFile, rb_intern("read"), 1, rargs[0]); <.>
    rargs2[1] = rargs[0];
    rargs2[2] = rargs[1];

    rb_obj_instance_eval(2, rargs2, rargs[1]); <.>

     return Qnil;
 } /* }}} */
----
<.> Then we use the internal symbol  `rb_cFile` to call `File#read` on our arguments
<.> And then a final eval - see we adhere to the motto!

==== Error handling

Actually we covered this already in the previous section, so nothing to be done here and time to
move on.

.https://knowyourmeme.com/memes/white-rabbit-pointing-at-a-clock
image::meme-white_rabbit.png[Meme White Rabbit]

=== Integrating JavaScript

During the 2020s lots of weird things happen, but it was also the time when I was forced into my own
sort of crisis and had to use {macOS}[macOS] for some years.
Needless to say the window management totally annoyed me and I started another highly ambitious
project aptly named {touchjs}[touchjs].

There, I tied the newfootnote:[To me at least..] {touchbar}[Touch Bar], basic window management via
{accessapi}[Accessibility API] and a JavaScript integration based on {duktape}[duktape] together.

==== Time for Screenshots

From an easy task back to a more complicated:
Somehow I and totally unexplainable to me, I forgot to check in some essential headers to the
project and there are quite some blocking issues on build:

.Build attempt #1 of {touchjs}[touchjs]
[source,shell]
----
$ make
clang -c -mmacosx-version-min=10.12 -x objective-c src/touchjs.m -o src/touchjs.o
src/touchjs.m:17:10: fatal error: 'delegate.h' file not found
   17 | #include "delegate.h"
      |          ^~~~~~~~~~~~
1 error generated.
make: *** [src/touchjs.o] Error 1
----

.Build attempt #2 of {touchjs}[touchjs]
[source,shell]
----
$ make
clang -c -mmacosx-version-min=10.12 -x objective-c src/touchbar.m -o src/touchbar.o
src/touchbar.m:57:23: error: use of undeclared identifier 'kQuit'
   57 |     [array addObject: kQuit];
      |                       ^
src/touchbar.m:149:21: warning: class method '+presentSystemModalTouchBar:systemTrayItemIdentifier:' not found (return type defaults to 'id') [-Wobjc-method-access]
  149 |         [NSTouchBar presentSystemModalTouchBar: self.groupTouchBar
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  150 |             systemTrayItemIdentifier: kGroupButton];
      |             ~~~~~~~~~~~~~~~~~~~~~~~~
src/touchbar.m:150:39: error: use of undeclared identifier 'kGroupButton'; did you mean 'kGroupIcon'?
  150 |             systemTrayItemIdentifier: kGroupButton];
      |                                       ^~~~~~~~~~~~
      |                                       kGroupIcon

# --- %< --- snip --- %< ---
----

It took me quite some time figuring out how to restore the missing parts and thankfully I found them
in a backup.
Still, there has never been a real usage of the project on my side, _but_ I can show off
test scripts in JavaScriptfootnote:[Adding {Obj-C}[Obj-c] to this mix is something for another post..]
of the API along with some shots of the Touch Bar on a borrowed MacBook Pro:

.{touchjs}[touchjs]/test/observer.js:1
[source,javascript]
----
/* WM */
var wm = new TjsWM(); // <.>

tjs_print("wm: trusted=" + wm.isTrusted());

/* Events */
wm.observe("win_open", function (win) {
    tjs_print("Open: name=" + win.getTitle() + ", id=" + win.getId() + ", frame=" + win.getFrame()); // <.>
});
----
<.> Highly ambitious as I've promised
<.> Well, just print some details of windows in the normal state

.Screenshotfootnote:[Just kidding - see next shots!] of {touchjs}[touchjs/test/observer.js] (1/3)
image::touchjs-iterm-observer.png[Screenshot of touchjs (1/3)]
image::touchjs-touchbar-observer.png[Screenshot of touchjs (1/3)]

And some more with the actual UI:

.{touchjs}[touchjs]/test/button.js:1
[source,javascript]
----
var b = new TjsButton("Test")
    .setBgColor(255, 0, 0)
    .bind(function () {
      tjs_print("Test");
    });

/* Attach */
tjs_attach(b);
----

."Barshot" of {touchjs}[touchjs/test/button.js] (2/3)
image::touchjs-touchbar-button.png[Screenshot of touchjs (2/3)]

."Barshot" of {touchjs}[touchjs/test/widgets.js] (2/3)
image::touchjs-touchbar-widgets.png[Screenshot of touchjs (3/3)]

I ultimately got rid of macOS once-for-all, but before that I did more shenanigans in a sh iny new
project!
Since I got tired of Obj-C, I made the decision this is all for naught and started again with Rust.
This was around 2023 and the glorious project name {rubtle}[rubtle] in 2023.


==== Runtime loading

==== Error handling

=== Recap

|===
| Ease of use | Richness of API | Language agnostic | Error handling | Performance
|===

== Webassembly

=== Screenshots first

=== Runtime loading

=== Error handling

=== Recap

|===
| Ease of use | Richness of API | Language agnostic | Error handling
|===



I ultimately got rid of macOS once-for-all, but before that I did more shenanigans in a sh iny new
project!
Since I got tired of Obj-C, I made the decision this is all for naught and started again with Rust.
This was around 2023 and the glorious project name {rubtle}[rubtle] in 2023.


==== Runtime loading

==== Error handling

=== Recap

|===
| Ease of use | Richness of API | Language agnostic | Error handling | Performance
|===

== Webassembly

=== Screenshots first

=== Runtime loading

=== Error handling

=== Recap

|===
| Ease of use | Richness of API | Language agnostic | Error handling
|===

== Conclusion

The list of examples is quite long, but please help yourself:

- <{deskbar}>
- <{subtle}>
- <{subtle-rs}>
- <{touchjs}>
- <{rubtle}>
