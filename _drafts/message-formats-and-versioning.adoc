---
layout: post
title: Message formats and versioning
date: %%%DATE%%%
last_updated: %%%DATE%%%
author: Christoph Kappel
tags: showcase
categories: kafka avro apicurio karapace showcase
toc: true
---
:imagesdir: /assets/images/message-formats-and-versioning.adoc

// https://json-schema.org/
// https://www.liquid-technologies.com/online-json-to-schema-converter

When you send a letter to someone else it probably helps, when all participants of this exchange
speak the same language and it can't be wrong, when the format of the letter is something all sides
can handle safely.
Obviously, the same is true for inter-service-communication, but unlike snail mail the message
format will most likely change over time.

In this article we take a closer look at two pretty common problems and talk about ways to handle
these situations:

- How can we make sure both sides understand the same format?
- How can we share the actual format?

== Common understanding

The first step in using a common format is to pick one and make it default.
For a starter, [JSON][] is quite common between services, although nobody in their right mind would
pick it for a letter exchange:

[source,json]
----
{
    "title": "First",
    "description": "Bla",
    "done": null,
    "dueDate": "2022-11-21",
    "id": 0
}
----

This format is straight forward and modern JSON parsers are mature enough to handle `NULL` values
in any direction.
So, when something optional is unset we aren't bothered and on the other hand when something is
amiss we are gracefully pointed to the problem.

=== Evolving the format

There normally shouldn't be any surprises waiting for us - until we do something like this:

[source,json]
----
{
    "title": "First",
    "description": "Bla",
    "done": null,
    "dueDate": {
        "startDate": "2022-11-20",
        "dueDate": "2022-11-21"
    },
    "id":0
}
----

Here we evolve our `dueDate` field from a simple string to an object consisting of a **start** and
a **due** date - which is quite incompatible to the predecessor.

At this point nothing stops us from building a mapping layer in-between, but please put that
thought aside and follow me to the next chapter.

So we probably agree versioning the obvious solution to our problem, but what exactly - the
endpoint itself or rather our message?

=== Apply versioning

Let us consider both on a simple REST example, because I am quite sure you have seen something
like the following before.

==== Endpoint versioning

[source,shell]
----
$ curl -X GET http://blog.unexist.dev/api/1/todos # <1>
----
<1> Set the version via [path parameter][]

Our first option is to make the version number part of the [URI][], which allows us basically
every tracking and redirection possible with URI and is pretty common for API endpoints.

|===
| Pro | Con
| Clean separation of the endpoints
| Lots of copy/paste or worse people thinking about [DRY][]

| Deprecation of the endpoint can be tracked e.g. with [PACT][]
|

|
| Further evolution requires a new endpoint
|===

==== Message versioning

[source,shell]
----
$ curl -X GET -H “Accept: application/vnd.xm.device+json; version=1” http://blog.unexist.dev/api/todos # <1>
----
<1> Set the version via [Accept header][]

And the second option is to serve all versions from a single endpoint and honor the
[Accept header][] of the client.
This moves the content negotiation part to the client and it can pick the format that is well and
proper.

|===
| Pro | Con
| Single version of endpoint
| Increases the complexity of the endpoint to include version handling

|
| Difficult to track, if the version is still in use

| New versions can be easily added and served
|
|===

=== What to pick?

Like so often in IT, both options have their merits and it depends on what you are really up to.

In big architectures, it can be useful to be able to serve different versions of your messages on
different microservices and keep them really small and simple (see [KISS][]).
PACT can also help here to keep track of the different versions available and also provide insights
to the actual use patterns.

From a nitpicking perspective, versioning the actual content is preferable, because you have in
fact just one version of the endpoint - it just serves a different format.
And letting clients pick whatever they support is something that is also deeply ingrained into the
whole REST idea.

So whatever you pick, both options allow the client to select a version, either by route or by
header and the first problem is addressed.

== Share the format

When you want to share something abstract like a format you need some kind of formalism or way
to really describe it.
Like, if you look back at your schools days, I bet you've had to deal with the formal requirements
of how to write a business letter - so people on the receiving end really think you are serious.

=== Define a schema

Defining a schema for a structured format like [JSON][] is pretty easy and some people already did
the grunt work for us and invented [JSON Schema][].

It allows us to describe the fields and also our expectations about content inside of it.
And even better, converting our previous example is so easy, it can be done automatically by a
converter like [this one][]:

[source,json]
----
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "title": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "done": {
      "type": "null"
    },
    "dueDate": {
      "type": "string"
    },
    "id": {
      "type": "integer"
    }
  },
  "required": [
    "title",
    "description",
    "done",
    "dueDate",
    "id"
  ]
}
----

If we keep in line with our analogy, we need some kind of schoolbook now to write some lengthy
chapter about our format, so teacher can give meaningful lectures about it.

We rather skip this and talk about [schema registries][].

=== Make it public