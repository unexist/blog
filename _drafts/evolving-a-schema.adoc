---
layout: post
title: Evolving a format
date: %%%DATE%%%
last_updated: %%%DATE%%%
author: Christoph Kappel
tags: showcase
categories: json jsonschema avro thrift protobuf apicurio showcase
toc: true
---
////
https://json-schema.org/
https://www.liquid-technologies.com/online-json-to-schema-converter
https://konbert.com/convert/json/to/avro
http://thomasburette.com/blog/2014/05/25/so-you-want-to-write-your-own-CSV-code/
////

Modern distributed systems consist of dozens of different services and each of these needs to
communicate with others to fulfill tasks.
Without a well-known and understood format things can become messy, once data needs to go down to
the wire.

The first part of this article compares the textual format [JSON][] with the binary-based
[Avro][] and lays out how both can be evolved on a format level.
And the second part explains how the same can be archived with versions on examples based on
[REST][].

NOTE: This articles uses the usually Todo object found in many of the posts of this blog - if you
haven't seen it before, an [OpenAPI][] definition can be found here:
<https://blog.unexist.dev/redoc/#tag/Todo>

== Picking a format

This should be fairly, since anything that can be parsed on the receiving end **is** a proper
format, so we just serialize (or encode) our object values separated by commas ([CSV][]):

[source,csv]
----
First,Bla,true,2022-11-21,0
----

Most of the languages ([Java][] included) provide proper and mature CSV-parser which can be quickly
hooked into our code.
This allows us to avoid the problems altogether the internet warns us about
[writing own CSV code][].

Wired up and deployed, our solutions works splendidly until.. the right time to cite and old greek:

[quote,Heraclitus,https://www.reference.com/world-view/said-only-thing-constant-change-d50c0532e714e12b]
Change is the only constant in life.


[source,csv]
----
title,description,done,dueDate,id
First,Bla,true,2022-11-21,0
----

=== Textual with JSON

[source,json]
----
{
    "title": "First",
    "description": "Bla",
    "done": true,
    "dueDate": "2022-11-21",
    "id": 0
}
----

[source,json]
----
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "title": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "done": {
      "type": "boolean"
    },
    "dueDate": {
      "type": "string"
    },
    "id": {
      "type": "integer"
    }
  },
  "required": [
    "title",
    "description",
    "done",
    "dueDate",
    "id"
  ]
}
----

=== Avro and the binary

[source,avro]
----
{
  "type": "record",
  "name": "Record",
  "fields": [
    {
      "name": "title",
      "type": "string"
    },
    {
      "name": "description",
      "type": "string"
    },
    {
      "name": "done",
      "type": "boolean"
    },
    {
      "name": "dueDate",
      "type": "string"
    },
    {
      "name": "id",
      "type": "long"
    }
  ]
}
----





== Apply versioning

There are multiple ways to apply versioning here, but let us limit ourselves to the two more common
ones usually found with [REST][].

=== Endpoint versioning

Our first option is to create a new version of our endpoint, by adding the version number to the
endpoint [URI][], which basically allows every kind of tracking and redirection magic:

[source,shell]
----
$ curl -X GET http://blog.unexist.dev/api/1/todos # <1>
----
<1> Set the version via [path parameter][]

|===
| Pro | Con
| Clean separation of the endpoints
| Lots of copy/paste or worse people thinking about [DRY][]

| Usage and therefore deprecation of the endpoint can be tracked e.g. with [PACT][]
|

|
| Further evolution might require a new endpoint
|===

=== Content versioning

And the second option is to serve all versions from a single endpoint by honoring client-provided
preferences here in the form of an [accept header][].
This has the additional benefit of offloading the content negotiation part to the client, so it can
pick the format it understands.

[source,shell]
----
$ curl -X GET -H “Accept: application/vnd.xm.device+json; version=1” http://blog.unexist.dev/api/todos # <1>
----
<1> Set the version via [Accept header][]

|===
| Pro | Con
| Single version of endpoint
| Increases the complexity of the endpoint to include version handling

|
| Difficult to track the actual usage of specific versions without header analysis

| New versions can be easily added and served
|
|===

=== What to pick?

Like so often in IT, both options have their merits and depend on what you are really up to.

In big architectures, it can be useful to be able to serve different versions of your messages on
different microservices and keep them really small and simple (see [KISS][]).
PACT can also help here to keep track of the different versions available and also provide insights
to actual use patterns.

From a nitpicking perspective, versioning the actual content is preferable, because you have in
fact just one version of the endpoint - it just serves a different version of your format.
And letting clients pick whatever they support is something that is also deeply ingrained into the
whole REST idea.

So whatever you pick, both options allow the client to select a version, either by route or by
header and the first problem is addressed.