---
layout: post
title: Evolving a schema
date: %%%DATE%%%
last_updated: %%%DATE%%%
author: Christoph Kappel
tags: showcase
categories: json jsonschema avro apicurio showcase
toc: true
---
////
https://json-schema.org/
https://www.liquid-technologies.com/online-json-to-schema-converter
https://konbert.com/convert/json/to/avro
https://blog.unexist.dev/redoc/#tag/Todo
////

Modern distributed systems consist of dozen of different services and they all need to be able
to communicate with each other to fulfill their intended tasks.
For this communication, the data needs to get down to the wire and here is where things are becoming
interesting.

Without any further changes, this would be pretty easy to deal with, but unfortunately life is
never easy:

[quote,Heraclitus,https://www.reference.com/world-view/said-only-thing-constant-change-d50c0532e714e12b]
Change is the only constant in life.

The first part of this article compares the textual format [JSON][] with the binary-based
[Avro][] and the second part why it is necessary to think about how to evolve formats.

== Picking a format

There are few viable options that can be used as for the kind of format, so let us take a shortcut here and pick the
current gold standard [JSON][].
Modern JSON parsers are pretty mature and can handle trivial cases like when something optional is
unset and gracefully point us to the problem, when something essential is amiss.

Let us start with small example for a simple [Todo][] entry and see what kind of data must be
included:

[source,json]
----
{
    "title": "First",
    "description": "Bla",
    "done": true,
    "dueDate": "2022-11-21",
    "id": 0
}
----

[source,avro]
----
{
  "type": "record",
  "name": "Record",
  "fields": [
    {
      "name": "title",
      "type": "string"
    },
    {
      "name": "description",
      "type": "string"
    },
    {
      "name": "done",
      "type": "boolean"
    },
    {
      "name": "dueDate",
      "type": "string"
    },
    {
      "name": "id",
      "type": "long"
    }
  ]
}
----

That looks like it covers our current requirements, but can hardly be called a schema right now.

=== Convert it to a schema

Remember we picked the gold standard?
This comes with additional goodies - like [JSON Schema][], which is perfectly suited to describe
our fields and also our expectations of the content inside of it.

And even better, converting our previous example is so easy, it can be done automatically with the
help of a converter like [this one][]:

[source,json]
----
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "title": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "done": {
      "type": "null"
    },
    "dueDate": {
      "type": "string"
    },
    "id": {
      "type": "integer"
    }
  },
  "required": [
    "title",
    "description",
    "done",
    "dueDate",
    "id"
  ]
}
----

Equipped with this we can verify data and also use it as a reference of what we exepect.

=== Distribute it

There normally shouldn't be any surprises waiting for us - until we do something nasty.

=== Time to break it

In our scenario, we got the requirement to evolve our `dueDate` field from a simple _string_ to an
_object_ consisting of a **start** and a **due** date - which unfortunately is quite
incompatible:

[source,json]
----
{
    "title": "First",
    "description": "Bla",
    "done": null,
    "dueDate": {
        "startDate": "2022-11-20",
        "dueDate": "2022-11-21"
    },
    "id":0
}
----

Our problem here can be solved by some kind of mapping layer, but we normally want to avoid adding
more complexity and code to maintain.

What if we just create a new version of our format?

=== Does versioning help?

There are multiple ways to apply versioning here, but let us limit ourselves to the two more common
ones usually found with [REST][].

==== Endpoint versioning

Our first option is to create a new version of our endpoint, by adding the version number to the
endpoint [URI][], which basically allows every kind of tracking and redirection magic:

[source,shell]
----
$ curl -X GET http://blog.unexist.dev/api/1/todos # <1>
----
<1> Set the version via [path parameter][]

|===
| Pro | Con
| Clean separation of the endpoints
| Lots of copy/paste or worse people thinking about [DRY][]

| Usage and therefore deprecation of the endpoint can be tracked e.g. with [PACT][]
|

|
| Further evolution might require a new endpoint
|===

==== Content versioning

And the second option is to serve all versions from a single endpoint by honoring client-provided
preferences here in the form of an [accept header][].
This has the additional benefit of offloading the content negotiation part to the client, so it can
pick the format it understands.

[source,shell]
----
$ curl -X GET -H “Accept: application/vnd.xm.device+json; version=1” http://blog.unexist.dev/api/todos # <1>
----
<1> Set the version via [Accept header][]

|===
| Pro | Con
| Single version of endpoint
| Increases the complexity of the endpoint to include version handling

|
| Difficult to track the actual usage of specific versions without header analysis

| New versions can be easily added and served
|
|===

=== What to pick?

Like so often in IT, both options have their merits and depend on what you are really up to.

In big architectures, it can be useful to be able to serve different versions of your messages on
different microservices and keep them really small and simple (see [KISS][]).
PACT can also help here to keep track of the different versions available and also provide insights
to actual use patterns.

From a nitpicking perspective, versioning the actual content is preferable, because you have in
fact just one version of the endpoint - it just serves a different version of your format.
And letting clients pick whatever they support is something that is also deeply ingrained into the
whole REST idea.

So whatever you pick, both options allow the client to select a version, either by route or by
header and the first problem is addressed.





[source,json]
----
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "title": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "done": {
      "type": "null"
    },
    "dueDate": {
      "type": "string"
    },
    "id": {
      "type": "integer"
    }
  },
  "required": [
    "title",
    "description",
    "done",    "dueDate",
    "id"
  ]

}
----

If we keep in line with our analogy, we need some kind of schoolbook now to write some lengthy
chapter about our format, so teacher can give meaningful lectures about it.

We rather skip this and talk about [schema registries][].

=== Make it public

