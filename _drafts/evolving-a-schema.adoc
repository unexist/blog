---
layout: post
title: Evolving a schema
date: %%%DATE%%%
last_updated: %%%DATE%%%
author: Christoph Kappel
tags: showcase
categories: kafka jsonschema avro apicurio karapace showcase
toc: true
---
// https://json-schema.org/
// https://www.liquid-technologies.com/online-json-to-schema-converter

Modern distributed systems consist of dozen of different services and they all need to be able
to communicate with each other to fulfill their intended tasks.
Getting this data to the wire requires some kind of serialization - so some decisions must be made
upfront.

Based on the actual use case, we consider points like thru-put, error handling, support of our
endpoint technology and ease of use - but unfortunately rarely how can our chosen format be changed.

[quote,Heraclitus,https://www.reference.com/world-view/said-only-thing-constant-change-d50c0532e714e12b]
Change is the only constant in life.

The first part of this article explains why it is necessary to think about how to evolve
formats from start and demonstrates two of the more common ways to handle this with [REST][].
And the second part introduces [Avro][] and explains ways can be done with [Kafka][].

== How to evolve formats?

There are few viable options for the kind of format, but I daresay the current gold standard here
is just [JSON][].

Modern JSON parsers are pretty mature and handle some of surprises in a sane way.
This can save us from handling trivial cases like when something optional is unset and we are
gracefully pointed to the problem, when something essential is amiss.

==== Breaking the format

[source,json]
----
{
    "title": "First",
    "description": "Bla",
    "done": null,
    "dueDate": "2022-11-21",
    "id": 0
}
----



There normally shouldn't be any surprises waiting for us - until we do something like nasty.


In our scenario, we got the requirement to evolve our `dueDate` field from a simple _string_ to an
_object_ consisting of a **start** and a **due** date - which unfortunately is quite
incompatible:

[source,json]
----
{
    "title": "First",
    "description": "Bla",
    "done": null,
    "dueDate": {
        "startDate": "2022-11-20",
        "dueDate": "2022-11-21"
    },
    "id":0
}
----

This is something that can be solved by some kind of mapping layer, but we normally want to avoid
adding more complexity and code to maintain.

What if we just create a new version of our format?

=== Apply versioning to..?

There are multiple ways to apply versioning here, but let us limit ourselves to the two more common
ones usually found with [REST][].

==== Endpoint versioning

Our first option is to create a new version of our endpoint, by adding the version number to the
endpoint [URI][], which basically allows every kind of tracking and redirection magic:

[source,shell]
----
$ curl -X GET http://blog.unexist.dev/api/1/todos # <1>
----
<1> Set the version via [path parameter][]

|===
| Pro | Con
| Clean separation of the endpoints
| Lots of copy/paste or worse people thinking about [DRY][]

| Usage and therefore deprecation of the endpoint can be tracked e.g. with [PACT][]
|

|
| Further evolution might require a new endpoint
|===

==== Content versioning

And the second option is to serve all versions from a single endpoint by honoring client-provided
preferences here in the form of an [Accept header][].
This has the additional benefit of offloading the content negotiation part to the client, so it can
pick the format it understands.

[source,shell]
----
$ curl -X GET -H “Accept: application/vnd.xm.device+json; version=1” http://blog.unexist.dev/api/todos # <1>
----
<1> Set the version via [Accept header][]

|===
| Pro | Con
| Single version of endpoint
| Increases the complexity of the endpoint to include version handling

|
| Difficult to track the actual usage of specific versions without header analysis

| New versions can be easily added and served
|
|===

=== What to pick?

Like so often in IT, both options have their merits and depend on what you are really up to.

In big architectures, it can be useful to be able to serve different versions of your messages on
different microservices and keep them really small and simple (see [KISS][]).
PACT can also help here to keep track of the different versions available and also provide insights
to the actual use patterns.

From a nitpicking perspective, versioning the actual content is preferable, because you have in
fact just one version of the endpoint - it just serves a different version of your format.
And letting clients pick whatever they support is something that is also deeply ingrained into the
whole REST idea.

So whatever you pick, both options allow the client to select a version, either by route or by
header and the first problem is addressed.

== Share the format

When you want to share something abstract like a format, you need some kind of formalism or way
to really describe it.
Like, if you look back at your schools days, I bet you've had to deal with the formal requirements
of how to write a business letter - so people on the receiving end really have the impression you
are serious.

=== Define a schema

Defining a schema for a structured format like [JSON][] is pretty easy and some people already did
the grunt work for us by inventing [JSON Schema][].

This allows us to describe the fields and also our expectations of the content inside of it.
And even better, converting our previous example is so easy, it can be done automatically with the
help of a converter like [this one][]:

[source,json]
----
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "title": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "done": {
      "type": "null"
    },
    "dueDate": {
      "type": "string"
    },
    "id": {
      "type": "integer"
    }
  },
  "required": [
    "title",
    "description",
    "done",    "dueDate",
    "id"
  ]

}
----

If we keep in line with our analogy, we need some kind of schoolbook now to write some lengthy
chapter about our format, so teacher can give meaningful lectures about it.

We rather skip this and talk about [schema registries][].

=== Make it public

